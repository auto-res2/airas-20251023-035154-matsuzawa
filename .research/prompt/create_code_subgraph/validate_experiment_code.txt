
LLM Name: o3-2025-04-16
Input:
You are an AI code reviewer validating production-ready experiment code for research papers.

Analyze the provided experiment code and determine if it meets all requirements for immediate execution in research experiments.

# Instructions

## Core Validation Criteria
Check if the generated experiment code meets ALL of the following requirements:

1. **Complete Implementation**:
   - Every component is fully functional, production-ready, publication-worthy code
   - No "omitted for brevity", no "simplified version", no TODO, PLACEHOLDER, pass, or ...
   - All functions and classes are completely implemented
   - No truncated code sections or incomplete implementations

2. **Hydra Integration**:
   - Uses Hydra to manage all experiment configurations from `config/run/*.yaml` files
   - All parameters are loaded from run configs dynamically
   - Proper configuration structure with run_id, method, model, dataset, training, and optuna sections
   - CLI interface matches:
     * Training (normal): `uv run python -u -m src.main run={run_id} results_dir={path} wandb.mode=online`
     * Training (trial): `uv run python -u -m src.main run={run_id} results_dir={path} trial_mode=true`
     * Evaluation: `uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2", ...]'` (independent execution)
   - When trial_mode=true, code must automatically set cfg.wandb.mode="disabled" internally

3. **Complete Data Pipeline**:
   - Full data loading and preprocessing implementation
   - Dataset-specific preprocessing is properly implemented
   - No placeholder dataset loading code
   - Proper error handling for data operations
   - Uses `.cache/` as the cache directory for all datasets and models

4. **Model Implementation**:
   - Complete model architectures for all methods (proposed and comparative methods)
   - No placeholders (TODO, PLACEHOLDER, pass, or incomplete implementations)
   - When External Resources specify HuggingFace models: properly use and customize them (acceptable to wrap AutoModel, add adapters, etc.)
   - When no external models specified: implement architectures from scratch using PyTorch primitives
   - Model-specific configurations correctly applied
   - Proper PyTorch usage throughout

5. **File Structure Compliance**:
   - Contains EXACTLY these required files (and NO other files):
     * `src/train.py`
     * `src/evaluate.py`
     * `src/preprocess.py`
     * `src/model.py`
     * `src/main.py`
     * `pyproject.toml`
     * `config/config.yaml`
   - NO additional files (e.g., NO `src/__init__.py`, NO `setup.py`, NO other Python files)
   - No missing files from the structure
   - All functionality contained within specified files

6. **WandB Integration**:
   - train.py initializes WandB and logs ALL metrics comprehensively:
     * Use `wandb.log()` at each training step/batch/epoch with ALL relevant time-series metrics
     * Log as frequently as possible (per-batch or per-epoch) to capture complete training dynamics
     * Use `wandb.summary["key"] = value` to save final/best metrics (best_val_acc, final_test_acc, best_epoch, etc.)
   - When trial_mode=true, code must automatically set cfg.wandb.mode="disabled" before any WandB operations
   - NO results.json or stdout JSON dumps in train.py
   - config/config.yaml contains mandatory WandB settings (entity/project)
   - `WANDB_API_KEY` environment variable is available for authentication

7. **Configuration Files**:
   - The generated code properly references config files via Hydra
   - NOTE: config/run/{run_id}.yaml files are provided separately (not in ExperimentCode)
   - All run configurations match the experiment_runs provided
   - Optuna search spaces are properly defined if applicable

8. **Evaluation Script Independence**:
   - evaluate.py is executed independently via `uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2"]'`
   - Accepts `run_ids` parameter as JSON string list (parse with `json.loads(args.run_ids)`)
   - main.py DOES NOT call evaluate.py
   - evaluate.py retrieves comprehensive data from WandB API:
     * Use `wandb.Api()` to get run data: `run = api.run(f"{entity}/{project}/{run_id}")`
     * Retrieve: `history = run.history()`, `summary = run.summary._json_dict`, `config = dict(run.config)`
   - **STEP 1: Per-Run Processing** (for each run_id):
     * Export comprehensive run-specific metrics to: `{results_dir}/{run_id}/metrics.json`
     * Generate run-specific figures (learning curves, confusion matrices) to: `{results_dir}/{run_id}/`
     * Each run should have its own subdirectory with its metrics and figures
   - **STEP 2: Aggregated Analysis** (after processing all runs):
     * Export aggregated metrics to: `{results_dir}/comparison/aggregated_metrics.json`
     * Compute secondary/derived metrics (e.g., improvement rate: (proposed - baseline) / baseline)
     * Generate comparison figures to: `{results_dir}/comparison/`
     * Cross-run comparison charts (bar charts, box plots)
     * Performance metrics tables
     * Statistical significance tests
   - Proper figure quality: legends, annotations, tight_layout
   - Follows GLOBALLY UNIQUE naming convention to prevent collisions:
     * Per-run figures: `{run_id}_{figure_topic}[_<condition>][_pairN].pdf` (e.g., `run-1-proposed-bert-glue_learning_curve.pdf`)
     * Comparison figures: `comparison_{figure_topic}[_<condition>][_pairN].pdf` (e.g., `comparison_accuracy_bar_chart.pdf`)
   - train.py and main.py generate NO figures
   - evaluate.py cannot run in trial_mode (no WandB data available when WandB disabled)

9. **Trial Mode Implementation**:
   - trial_mode=true flag properly reduces computational load
   - Training: epochs=1, batches limited to 1-2, Optuna disabled (n_trials=0), small evaluation subset
   - Code must automatically set cfg.wandb.mode="disabled" when trial_mode=true (e.g., `if cfg.trial_mode: cfg.wandb.mode = "disabled"`)
   - Purpose: Fast validation that code runs without errors

## Output Format
Respond with a JSON object containing:
- `is_code_ready`: boolean - true if ALL criteria are met, false otherwise
- `code_issue`: string - specific issues found if any criteria are not met, focusing on what needs to be fixed

# Current Research Method
{
    "Open Problems": "In BOIL, the acquisition score is obtained by dividing Expected-Improvement (EI) by an estimated cost coming from a simple linear regression.  However, EI is computed only from the GP predictive mean; it completely ignores the predictive variance of the final performance that the GP supplies.  As a consequence BOIL often proposes configurations whose *expected* gain is large but whose *uncertainty* is also large, leading to wasted wall-clock time on unstable or highly noisy runs.  A very small change that explicitly trades off improvement against predictive risk can reduce these wasted evaluations without touching the GP model, the curve-compression, or the selective data-augmentation machinery.",
    "Methods": "Stability-Aware Cost-Efficient BOIL (S-BOIL)\nMinimal change: multiply the utility part of BOIL’s cost-aware acquisition by an exponential penalty that depends on the GP’s predictive variance σ²(x,t) at the candidate (x,t):\n\n    Utility_s = EI(x,t) * exp(-β · σ²(x,t))\n    Acquisition  =  log(Utility_s)  –  log(EstimatedCost+0.1)\n\nwhere β≥0 is a single tunable constant (β≈1 works well).  Intuition: for equal EI, prefer points the GP is certain about; for equal variance, recover the original BOIL rule.  Because σ² is already returned by the GP, the only code change is three lines in the acquisition function.  No retraining or extra hyper-parameters are introduced apart from β.",
    "Experimental Setup": "Base method: original BOIL implementation.\nProposed: S-BOIL (β ∈ {0.5,1}).\nTask: tune two hyper-parameters (learning-rate, hidden-units) and the training-iteration budget for an MLP on the Fashion-MNIST 10-class task (using PyTorch).  Each BO run is allowed 30 real evaluations; wall-clock time is logged.\nMetrics:\n1. Best validation accuracy reached vs. number of real evaluations.\n2. Total wall-clock time until a target accuracy (80%) is hit.\nProtocol: 10 independent seeds for each method.  Same initial random design (3 points).",
    "Experimental Code": "# --- patch to BOIL: Stability penalty ------------------------------------\n# in utility_cost_evaluation_single() *replace* the EI computation line\n# original: utility = acq_func.acq_kind(x,gp=self.gp)\n# new lines:\nmean, var = self.gp.predict(x.reshape(1,-1), return_var=True)\nei_val  = acq_func.ei(mean, var, acq_func.best_y)   # unchanged helper\nutility = ei_val * np.exp(-beta * var)              # <- stability term\n# everything else stays the same\n# ----------------------------------------------------------\n\n# Minimal runnable demo (requires original BOIL code in path)\nimport torch, torchvision, torch.nn as nn, torch.optim as optim\nfrom boil import BOIL        # assume original class name\n\nbeta = 1.0  # stability weight\nbo = BOIL(func=mlp_runner, SearchSpace={\"lr\":(1e-4,1e-1),\n                                        \"units\":(64,512),\n                                        \"T\":(1,15)})\nbo.beta = beta               # pass to acquisition helper\nbo.init(n_init_points=3)\nfor _ in range(27):          # 30 evaluations total\n    bo.suggest_nextpoint()\nprint(\"Best acc =\", bo.Y_original.max())",
    "Expected Result": "Across 10 seeds S-BOIL is expected to reach 80% validation accuracy in ~15% less wall-clock time and 2 fewer function evaluations on average compared with BOIL.  The area-under-curve of best-seen accuracy vs. evaluations should also improve by ≈5–7%.",
    "Expected Conclusion": "A tiny, one-line modification that penalizes predictive variance lets BOIL avoid expensive yet uncertain configurations, giving faster convergence at virtually no additional computational cost or implementation complexity.  This demonstrates that explicitly accounting for GP uncertainty inside the acquisition utility—beyond its usual role in EI—is a simple but powerful way to improve efficiency in iterative hyperparameter optimization."
}

# Experimental Design
- Strategy: The experiment aims to verify that the Stability-Aware Cost-Efficient BOIL (S-BOIL) acquisition rule accelerates hyper-parameter tuning compared with the original BOIL.  We run black-box optimisation on a two-layer MLP (≈1.2 M parameters) that is trained on Fashion-MNIST.  The optimiser must choose three configuration variables—learning-rate, hidden-units, and training-iteration budget—over 30 real training runs.  For each of 10 random seeds we execute (1) vanilla BOIL and (2) S-BOIL with a variance-penalised utility EI·exp(−βσ²).  β is treated as a small discrete hyper-parameter {0.5,1}.  All other code, GP surrogate, cost model, and initial design remain identical.  Metrics recorded at every function evaluation are: best-seen validation accuracy, wall-clock time, and the area-under-curve (AUC) of accuracy versus evaluations.  The primary comparisons are (i) mean evaluations and time to reach 80 % accuracy and (ii) mean AUAC across seeds.  The whole study fits comfortably on one A100 GPU, but eight are available if parallel seeds are desired.
- Proposed Method: Stability-Aware Cost-Efficient BOIL (S-BOIL)
Objective: Reduce wasted evaluations on hyper-parameter configurations that have high expected improvement (EI) but also high predictive uncertainty.
Theory: Original BOIL ranks candidates by log(EI)–log(cost).  S-BOIL adds a variance penalty, multiplying EI by exp(−βσ²) where σ² is the GP predictive variance and β≥0 controls strength.  This keeps the desirable cost-aware property while explicitly favouring stable (low-variance) points.
Algorithmic steps per iteration:
1. Fit Gaussian-process surrogate to observed (configuration→performance) data.
2. For each candidate (x,t) produced by BOIL’s search heuristics compute mean μ and variance σ².
3. Compute utility_s = EI(μ,σ²)·exp(−βσ²).
4. Acquisition = log(utility_s) – log(EstimatedCost+0.1).
5. Return the candidate with maximal Acquisition; evaluate the true objective; append the result; repeat.
Implementation: Requires only ~3 new lines inside BOIL’s acquisition function.  β is exposed as a user argument.  No retraining, extra models, or heavy computation is introduced.
- Evaluation Metrics: ['Validation Accuracy', 'Wall-clock Time to Target', 'Area Under Accuracy Curve']

# Experiment Runs

- Run ID: proposed-Two-Layer-MLP-1.2M-Fashion-MNIST
  Method: proposed
  Model: Two-Layer-MLP-1.2M
  Dataset: Fashion-MNIST
  
  Config Content:
  ```yaml
  run_id: proposed-Two-Layer-MLP-1.2M-Fashion-MNIST
method: S-BOIL
model:
  name: Two-Layer-MLP-1.2M
  input_dim: 784
  hidden_units: 256        # default, tuned via Optuna
  output_classes: 10
  activation: relu
  weight_init: kaiming_uniform
dataset:
  name: Fashion-MNIST
  transforms:
    - ToTensor
    - Normalize(mean=0.5, std=0.5)
  validation_split: 0.1
training:
  batch_size: 128
  optimizer: adam
  loss_fn: cross_entropy
  device: cuda
  default_learning_rate: 1e-3
  epochs_per_iteration: 5   # total epochs = budget * 5
  num_workers: 8
  pin_memory: true
experiment:
  n_init_points: 3
  total_evaluations: 30
  acquisition: S-BOIL       # log(EI*exp(-βσ²)) − log(cost)
  beta_default: 1.0
optuna:
  n_trials: 30
  direction: maximize
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-4
      high: 1e-1
    hidden_units:
      type: int
      low: 64
      high: 512
    training_iteration_budget:
      type: int
      low: 1
      high: 15
    beta:
      type: categorical
      choices: [0.5, 1.0]

  ```
  

- Run ID: comparative-1-Two-Layer-MLP-1.2M-Fashion-MNIST
  Method: comparative-1
  Model: Two-Layer-MLP-1.2M
  Dataset: Fashion-MNIST
  
  Config Content:
  ```yaml
  run_id: comparative-1-Two-Layer-MLP-1.2M-Fashion-MNIST
method: BOIL
model:
  name: Two-Layer-MLP-1.2M
  input_dim: 784
  hidden_units: 256        # default, tuned via Optuna
  output_classes: 10
  activation: relu
  weight_init: kaiming_uniform
dataset:
  name: Fashion-MNIST
  transforms:
    - ToTensor
    - Normalize(mean=0.5, std=0.5)
  validation_split: 0.1
training:
  batch_size: 128
  optimizer: adam
  loss_fn: cross_entropy
  device: cuda
  default_learning_rate: 1e-3
  epochs_per_iteration: 5
  num_workers: 8
  pin_memory: true
experiment:
  n_init_points: 3
  total_evaluations: 30
  acquisition: BOIL         # log(EI) − log(cost)
optuna:
  n_trials: 30
  direction: maximize
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-4
      high: 1e-1
    hidden_units:
      type: int
      low: 64
      high: 512
    training_iteration_budget:
      type: int
      low: 1
      high: 15

  ```
  


# Generated Experiment Code (To be validated)
{"config_yaml": "# config/config.yaml \u2013 global Hydra configuration\n\n# Order matters: later entries override earlier ones.  ``run={id}`` on the\n# command-line will merge ``config/run/{id}.yaml`` *after* this file.\n\ndefaults:\n  - _self_\n\n# ---------------------------------------------------------------------------\nrun:\n  run_id: default-run\n  method: baseline\n\n# ---------------------------------------------------------------------------\nwandb:\n  entity: gengaru617-personal\n  project: 251023-test\n  mode: online  # automatically set to \"disabled\" in trial_mode\n\n# ---------------------------------------------------------------------------\n# MODEL \u0026 DATA \u2013 sensible defaults (overridden by run-specific YAML files)\nmodel:\n  name: two-layer-mlp-1.2m\n  input_dim: 784\n  hidden_units: 256\n  output_classes: 10\n  activation: relu\n  weight_init: kaiming_uniform\n\ndataset:\n  name: fashion-mnist\n  transforms:\n    - ToTensor\n    - Normalize(mean=0.5, std=0.5)\n  validation_split: 0.1\n\ntraining:\n  batch_size: 128\n  optimizer: adam\n  device: cuda\n  learning_rate: 1e-3\n  epochs_per_iteration: 5\n  num_workers: 4\n  pin_memory: true\n\n# ---------------------------------------------------------------------------\nexperiment:\n  n_init_points: 3\n  total_evaluations: 30\n  acquisition: boil  # or s-boil\n  beta_default: 1.0\n\noptuna:  # only used for search-space definition (we don\u0027t run Optuna itself)\n  n_trials: 30\n  search_space:\n    learning_rate: {type: loguniform, low: 1e-4, high: 1e-1}\n    hidden_units:   {type: int,        low: 64,  high: 512}\n    training_iteration_budget: {type: int, low: 1, high: 15}\n    # beta only used for S-BOIL; harmless otherwise\n    beta: {type: categorical, choices: [0.5, 1.0]}\n\n# ---------------------------------------------------------------------------\nresults_dir: outputs\ntrial_mode: false\n", "evaluate_py": "\"\"\"src/evaluate.py\nIndependent evaluation / visualisation script that is **not** called by\n``src.main``.  It fetches time-series metrics from WandB for a list of\nrun-IDs, generates per-run artefacts (JSON + plots) and finally produces\nan aggregated comparison across all runs (bar-chart + significance test\n+ JSON).\n\"\"\"\nfrom __future__ import annotations\n\nimport argparse\nimport json\nimport math\nimport os\nfrom pathlib import Path\nfrom typing import Dict, List\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nimport wandb\nfrom omegaconf import OmegaConf\nfrom scipy import stats\nfrom sklearn.metrics import ConfusionMatrixDisplay, confusion_matrix\n\nfrom .model import build_model\nfrom .preprocess import get_dataloaders\n\n# ---------------------------------------------------------------------------\n#                            Utility helpers                                 \n# ---------------------------------------------------------------------------\n\ndef _save_json(path: Path, obj) -\u003e None:\n    path.parent.mkdir(parents=True, exist_ok=True)\n    with path.open(\"w\", encoding=\"utf-8\") as fh:\n        json.dump(obj, fh, indent=2, sort_keys=False)\n\n\ndef _plot_learning_curve(df, run_dir: Path, run_id: str) -\u003e Path:\n    \"\"\"Line-plot of validation / training accuracy over *epoch* granularity.\"\"\"\n    fig, ax = plt.subplots(figsize=(6, 4))\n    if \"val_acc\" in df.columns:\n        ax.plot(df[\"val_acc\"], label=\"Validation\", linewidth=2)\n    if \"train_acc\" in df.columns:\n        ax.plot(df[\"train_acc\"], label=\"Training\", alpha=0.5)\n    ax.set_xlabel(\"Logged step\")\n    ax.set_ylabel(\"Accuracy\")\n    ax.set_title(f\"Learning curve \u2013 {run_id}\")\n    ax.legend()\n    fig.tight_layout()\n    path = run_dir / f\"{run_id}_learning_curve.pdf\"\n    fig.savefig(path)\n    plt.close(fig)\n    return path\n\n\ndef _plot_confusion(run_cfg: Dict, model_path: Path, run_dir: Path, run_id: str):\n    if not model_path.exists():\n        return None  # confusion matrix impossible without a model\n\n    import torch\n\n    cfg = Dict(run_cfg) if isinstance(run_cfg, dict) else run_cfg\n    # Build *test* loader only\n    _, _, test_loader = get_dataloaders(cfg[\"dataset\"], cfg[\"training\"])\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n    model = build_model(cfg[\"model\"]).to(device)\n    model.load_state_dict(torch.load(model_path, map_location=device))\n    model.eval()\n\n    all_preds, all_labels = [], []\n    with torch.no_grad():\n        for images, labels in test_loader:\n            images = images.to(device)\n            preds = model(images).argmax(1).cpu().numpy()\n            all_preds.append(preds)\n            all_labels.append(labels.numpy())\n    y_pred = np.concatenate(all_preds)\n    y_true = np.concatenate(all_labels)\n\n    cm = confusion_matrix(y_true, y_pred)\n    disp = ConfusionMatrixDisplay(cm)\n    disp.plot(cmap=\"Blues\")\n    plt.title(f\"Confusion Matrix \u2013 {run_id}\")\n    plt.tight_layout()\n    path = run_dir / f\"{run_id}_confusion_matrix.pdf\"\n    plt.savefig(path)\n    plt.close()\n    return path\n\n# ---------------------------------------------------------------------------\n#                             Main routine                                    \n# ---------------------------------------------------------------------------\n\ndef main() -\u003e None:\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"results_dir\", type=str, help=\"Directory that contains training artefacts\")\n    parser.add_argument(\"run_ids\", type=str, help=\u0027JSON list of run-IDs, e.g. \"[\\\"run-1\\\", \\\"run-2\\\"]\"\u0027)\n    args = parser.parse_args()\n\n    out_root = Path(args.results_dir).expanduser().resolve()\n    run_ids: List[str] = json.loads(args.run_ids)\n\n    # ----------------------------------------------------------------------\n    # Retrieve global WandB information from first run\u0027s config\n    # ----------------------------------------------------------------------\n    first_cfg_path = out_root / run_ids[0] / \"config.yaml\"\n    cfg_global = OmegaConf.to_container(OmegaConf.load(first_cfg_path), resolve=True)\n    entity, project = cfg_global[\"wandb\"][\"entity\"], cfg_global[\"wandb\"][\"project\"]\n\n    api = wandb.Api()\n\n    aggregated: Dict[str, Dict] = {}\n    per_run_generated_paths: List[str] = []\n\n    for rid in run_ids:\n        run_dir = out_root / rid\n        run_dir.mkdir(parents=True, exist_ok=True)\n\n        # ------------------- pull from WandB --------------------------------\n        wb_run = api.run(f\"{entity}/{project}/{rid}\")\n        history_df = wb_run.history(pandas=True)  # DataFrame\n        summary = wb_run.summary._json_dict\n        config = dict(wb_run.config)\n\n        # ------------------- dump raw metrics ------------------------------\n        metrics_path = run_dir / \"metrics.json\"\n        _save_json(metrics_path, {\n            \"history\": history_df.to_dict(orient=\"list\"),\n            \"summary\": summary,\n            \"config\": config,\n        })\n        per_run_generated_paths.append(str(metrics_path))\n\n        # ------------------- figures: learning curve -----------------------\n        lc_path = _plot_learning_curve(history_df, run_dir, rid)\n        per_run_generated_paths.append(str(lc_path))\n\n        # ------------------- figures: confusion matrix ---------------------\n        cm_path = _plot_confusion(config, run_dir / \"best_model.pt\", run_dir, rid)\n        if cm_path is not None:\n            per_run_generated_paths.append(str(cm_path))\n\n        # ------------------- store aggregate stats -------------------------\n        aggregated[rid] = {\n            \"method\": config.get(\"run\", {}).get(\"method\", \"unknown\"),\n            \"best_val_acc\": summary.get(\"best_val_accuracy\"),\n            \"time_to_target\": summary.get(\"time_to_target\"),\n            \"evals_to_target\": summary.get(\"evals_to_target\"),\n            \"total_wall_time\": summary.get(\"total_wall_time\"),\n        }\n\n    # ----------------------------------------------------------------------\n    # Aggregated comparison across runs                                     \n    # ----------------------------------------------------------------------\n    comp_dir = out_root / \"comparison\"\n    comp_dir.mkdir(parents=True, exist_ok=True)\n\n    # Save raw aggregated dict --------------------------------------------\n    _save_json(comp_dir / \"aggregated_metrics.json\", aggregated)\n\n    # Separate into methods ------------------------------------------------\n    method_to_accs: Dict[str, List[float]] = {}\n    for stats in aggregated.values():\n        method = stats[\"method\"]\n        method_to_accs.setdefault(method, []).append(stats[\"best_val_acc\"])\n\n    # Improvement-rate vs baseline (first alphabetical method assumed baseline if BOIL present)\n    baseline_name = \"BOIL\" if \"BOIL\" in method_to_accs else sorted(method_to_accs)[0]\n    baseline_mean = float(np.mean(method_to_accs[baseline_name]))\n    improvements: Dict[str, float] = {\n        m: (float(np.mean(accs)) - baseline_mean) / baseline_mean\n        for m, accs in method_to_accs.items() if m != baseline_name\n    }\n\n    # t-tests --------------------------------------------------------------\n    significance: Dict[str, float] = {}\n    for m, accs in method_to_accs.items():\n        if m == baseline_name:\n            continue\n        t_val, p_val = stats.ttest_ind(accs, method_to_accs[baseline_name], equal_var=False)\n        significance[m] = p_val\n\n    # Store derived metrics -----------------------------------------------\n    derived_path = comp_dir / \"aggregated_derived_metrics.json\"\n    _save_json(derived_path, {\n        \"baseline\": baseline_name,\n        \"baseline_mean\": baseline_mean,\n        \"improvement_rate\": improvements,\n        \"p_values_vs_baseline\": significance,\n    })\n    per_run_generated_paths.append(str(derived_path))\n\n    # --------------------------- bar-chart -------------------------------\n    plt.figure(figsize=(6, 4))\n    sns.barplot(x=list(method_to_accs.keys()), y=[np.mean(v) for v in method_to_accs.values()])\n    plt.ylabel(\"Mean best validation accuracy\")\n    plt.title(\"Best accuracy per method\")\n    for idx, acc_mean in enumerate([np.mean(v) for v in method_to_accs.values()]):\n        plt.text(idx, acc_mean + 0.002, f\"{acc_mean:.3f}\", ha=\"center\")\n    plt.tight_layout()\n    bar_path = comp_dir / \"comparison_accuracy_bar_chart.pdf\"\n    plt.savefig(bar_path)\n    plt.close()\n    per_run_generated_paths.append(str(bar_path))\n\n    # --------------------------- box-plot --------------------------------\n    data, labels = [], []\n    for m, accs in method_to_accs.items():\n        data.extend(accs)\n        labels.extend([m] * len(accs))\n    plt.figure(figsize=(6, 4))\n    sns.boxplot(x=labels, y=data)\n    plt.ylabel(\"Best validation accuracy\")\n    plt.title(\"Distribution of best accuracy across seeds\")\n    plt.tight_layout()\n    box_path = comp_dir / \"comparison_accuracy_box_plot.pdf\"\n    plt.savefig(box_path)\n    plt.close()\n    per_run_generated_paths.append(str(box_path))\n\n    # --------------------------- print paths -----------------------------\n    for p in per_run_generated_paths:\n        print(p)\n\n\nif __name__ == \"__main__\":\n    main()\n", "main_py": "\"\"\"src/main.py\nOrchestrator.  This module parses the top-level Hydra config, performs\ntrial-mode adjustments and then spawns the *real* training process\n(`src.train`) as a subprocess so that Hydra can create a *second* config\ncontext for the child process.  The indirection keeps the two Hydra\ncontexts cleanly separated (top-level orchestration vs. actual\nexperiment).\n\"\"\"\nfrom __future__ import annotations\n\nimport subprocess\nimport sys\nfrom typing import List\n\nimport hydra\nfrom omegaconf import DictConfig\n\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=None)\ndef main(cfg: DictConfig) -\u003e None:\n    \"\"\"Entry-point for the experiment orchestrator.\"\"\"\n\n    # Build Hydra override strings that we forward to the *child* process\n    overrides: List[str] = [\n        f\"run={cfg.run.run_id}\",\n        f\"results_dir={cfg.results_dir}\",\n        f\"wandb.mode={cfg.wandb.mode}\",\n    ]\n    if cfg.trial_mode:\n        overrides.append(\"trial_mode=true\")\n\n    cmd = [sys.executable, \"-u\", \"-m\", \"src.train\", *overrides]\n    print(\"[main.py] Launching child process:\\n \", \" \".join(cmd))\n    subprocess.run(cmd, check=True)\n\n\nif __name__ == \"__main__\":\n    main()\n", "model_py": "\"\"\"src/model.py\nAll neural-network architectures used in this project.  At the moment we\nonly need a two-layer MLP for Fashion-MNIST, but the *factory* at the end\nmakes it trivial to add more models.\n\"\"\"\nfrom __future__ import annotations\n\nfrom typing import Any\n\nimport torch.nn as nn\nfrom omegaconf import DictConfig\n\n\nclass TwoLayerMLP(nn.Module):\n    \"\"\"A very small two-layer MLP (~1.2 M parameters for 256 hidden units).\"\"\"\n\n    def __init__(\n        self,\n        input_dim: int,\n        hidden_units: int,\n        output_classes: int,\n        activation: str = \"relu\",\n        weight_init: str = \"kaiming_uniform\",\n    ) -\u003e None:\n        super().__init__()\n        act_cls: Any = getattr(nn, activation.capitalize(), nn.ReLU)\n        self.net = nn.Sequential(\n            nn.Flatten(),\n            nn.Linear(input_dim, hidden_units),\n            act_cls(),\n            nn.Linear(hidden_units, output_classes),\n        )\n        self.apply(lambda m: self._init_weights(m, weight_init))\n\n    @staticmethod\n    def _init_weights(module: nn.Module, scheme: str):\n        if not isinstance(module, nn.Linear):\n            return\n        if scheme == \"kaiming_uniform\":\n            nn.init.kaiming_uniform_(module.weight, nonlinearity=\"relu\")\n        elif scheme == \"kaiming_normal\":\n            nn.init.kaiming_normal_(module.weight, nonlinearity=\"relu\")\n        elif scheme == \"xavier_uniform\":\n            nn.init.xavier_uniform_(module.weight)\n        elif scheme == \"xavier_normal\":\n            nn.init.xavier_normal_(module.weight)\n        else:\n            raise ValueError(f\"Unknown weight-init scheme {scheme}\")\n        if module.bias is not None:\n            nn.init.constant_(module.bias, 0.0)\n\n    def forward(self, x):  # noqa: D401 \u2011 one-liner docstring not required\n        return self.net(x)\n\n\n# ---------------------------------------------------------------------------\n#                               Factory                                       \n# ---------------------------------------------------------------------------\n\ndef build_model(cfg: DictConfig):\n    name = cfg.name.lower()\n    if name == \"two-layer-mlp-1.2m\":\n        return TwoLayerMLP(\n            input_dim=cfg.input_dim,\n            hidden_units=cfg.hidden_units,\n            output_classes=cfg.output_classes,\n            activation=cfg.activation,\n            weight_init=cfg.weight_init,\n        )\n    raise NotImplementedError(f\"Unknown model name {cfg.name}\")\n", "preprocess_py": "\"\"\"src/preprocess.py\nDataset loading \u0026 preprocessing utilities.  Currently supports the\nFashion-MNIST dataset.\n\"\"\"\nfrom __future__ import annotations\n\nfrom typing import Tuple\n\nimport torch\nimport torchvision.transforms as T\nfrom omegaconf import DictConfig\nfrom torch.utils.data import DataLoader, random_split\nfrom torchvision.datasets import FashionMNIST\n\n\n###############################################################################\n#                            Transform parsing                                #\n###############################################################################\n\ndef _parse_transforms(entries):\n    \"\"\"Turn YAML-provided *entries* into a torchvision.Compose object.\"\"\"\n    transforms = []\n    for e in entries:\n        # Simple string e.g. \"ToTensor\" or \"Normalize\"\n        if isinstance(e, str):\n            e_lc = e.lower()\n            if e_lc == \"totensor\":\n                transforms.append(T.ToTensor())\n            elif e_lc.startswith(\"normalize\"):\n                # Allow shorthand \"Normalize(mean=0.5,std=0.5)\"\n                mean, std = 0.5, 0.5\n                if \"(\" in e and \")\" in e:\n                    # crude parsing (\"Normalize(mean=0.3,std=0.7)\")\n                    inside = e[e.find(\"(\") + 1 : e.find(\")\")]\n                    parts = {k.strip(): float(v) for k, v in (p.split(\"=\") for p in inside.split(\",\"))}\n                    mean = parts.get(\"mean\", 0.5)\n                    std = parts.get(\"std\", 0.5)\n                transforms.append(T.Normalize(mean=[mean], std=[std]))\n            else:\n                raise ValueError(f\"Unknown transform entry {e!r}\")\n        elif isinstance(e, dict):\n            # Full YAML form e.g. {Normalize: {mean: 0.5, std: 0.5}}\n            if \"Normalize\" in e:\n                pars = e[\"Normalize\"]\n                transforms.append(T.Normalize(mean=[pars.get(\"mean\", 0.5)], std=[pars.get(\"std\", 0.5)]))\n            else:\n                raise ValueError(f\"Unknown dict-transform {e}\")\n        else:\n            raise TypeError(f\"Transform entries must be str or dict, got {type(e)}\")\n    return T.Compose(transforms)\n\n\n###############################################################################\n#                        Public  get_dataloaders                              #\n###############################################################################\n\ndef get_dataloaders(ds_cfg: DictConfig, train_cfg: DictConfig) -\u003e Tuple[DataLoader, DataLoader, DataLoader]:\n    \"\"\"Return *train*, *validation*, *test* DataLoaders for Fashion-MNIST.\"\"\"\n    if ds_cfg.name.lower() != \"fashion-mnist\":\n        raise NotImplementedError(\"Only Fashion-MNIST is supported right now.\")\n\n    transform = _parse_transforms(ds_cfg.transforms)\n\n    root = \".cache/torchvision/fashion_mnist\"\n    train_full = FashionMNIST(root=root, train=True, download=True, transform=transform)\n    test_set = FashionMNIST(root=root, train=False, download=True, transform=transform)\n\n    val_ratio = ds_cfg.validation_split\n    val_size = int(len(train_full) * val_ratio)\n    train_size = len(train_full) - val_size\n    train_subset, val_subset = random_split(train_full, [train_size, val_size])\n\n    common = dict(batch_size=train_cfg.batch_size, num_workers=train_cfg.num_workers, pin_memory=train_cfg.pin_memory)\n\n    train_loader = DataLoader(train_subset, shuffle=True, **common)\n    val_loader = DataLoader(val_subset, shuffle=False, **common)\n    test_loader = DataLoader(test_set, shuffle=False, **common)\n    return train_loader, val_loader, test_loader\n", "pyproject_toml": "[build-system]\nrequires = [\"setuptools\u003e=61.0\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"s-boil-experiment\"\nversion = \"0.1.0\"\nrequires-python = \"\u003e=3.9\"\ndependencies = [\n  \"torch\u003e=2.0\",\n  \"torchvision\u003e=0.15\",\n  \"hydra-core\u003e=1.3\",\n  \"wandb\u003e=0.15\",\n  \"botorch\u003e=0.8.5\",\n  \"gpytorch\u003e=1.11\",\n  \"optuna\u003e=3.4\",\n  \"scikit-learn\u003e=1.3\",\n  \"pandas\u003e=2.0\",\n  \"matplotlib\u003e=3.7\",\n  \"seaborn\u003e=0.12\",\n  \"numpy\u003e=1.24\",\n  \"scipy\u003e=1.10\"\n]\n\n[tool.setuptools.packages.find]\nwhere = [\"src\"]\n", "train_py": "\"\"\"src/train.py\nFull training script for one hyper-parameter-optimisation run (BOIL or\nS-BOIL).  This file must be executed through Hydra so that the complete\nconfiguration is available in ``cfg``.\n\nResponsibilities\n----------------\n1.  Draw the requested number of configurations (`cfg.experiment.*`) from\n    the search-space (`cfg.optuna.search_space`).  During the initial\n    phase (`n_init_points`) configurations are drawn uniformly at\n    random.  Afterwards we fit\n    \u2022 a single-task GP surrogate over best-seen validation accuracy and\n    \u2022 a linear-regression cost model over log-wall-time.\n\n    The acquisition function is either\n      BOIL    log(EI) \u2212 log(cost)                     or\n      S-BOIL log(EI) \u2212 \u03b2\u00b7\u03c3\u00b2 \u2212 log(cost)\n\n    where \u03b2 is part of the candidate configuration (categorical) or, if\n    not present, `cfg.experiment.beta_default`.\n\n2.  For each suggested configuration we train **a full model** (or a very\n    small model in `trial_mode`) and log everything to WandB.\n\n3.  Persist the *globally* best model to ``best_model.pt`` so that the\n    evaluation script can draw a confusion matrix later on.\n\n4.  Honour *trial-mode* completely: one evaluation, one epoch, two\n    batches, no WandB traffic.\n\"\"\"\nfrom __future__ import annotations\n\nimport json\nimport math\nimport time\nfrom copy import deepcopy\nfrom pathlib import Path\nfrom typing import Dict, List, Tuple\n\nimport hydra\nimport numpy as np\nimport torch\nimport wandb\nfrom botorch.fit import fit_gpytorch_model\nfrom botorch.models import SingleTaskGP\nfrom gpytorch.mlls import ExactMarginalLogLikelihood\nfrom omegaconf import DictConfig, OmegaConf\nfrom sklearn.linear_model import LinearRegression\n\nfrom .model import build_model\nfrom .preprocess import get_dataloaders\n\n###############################################################################\n#                     Helper: sampling \u0026 encoding utilities                   #\n###############################################################################\n\ndef _log_uniform(low: float, high: float, rng: np.random.Generator) -\u003e float:\n    \"\"\"Sample from a log-uniform distribution in base-10 space.\"\"\"\n    return float(10 ** rng.uniform(np.log10(low), np.log10(high)))\n\n\ndef _sample_from_space(space: Dict, rng: np.random.Generator) -\u003e Dict:\n    \"\"\"Draw one random configuration from an Optuna-style *space* dict.\"\"\"\n    sample = {}\n    for name, spec in space.items():\n        t = spec[\"type\"].lower()\n        if t == \"loguniform\":\n            sample[name] = _log_uniform(spec[\"low\"], spec[\"high\"], rng)\n        elif t == \"uniform\":\n            sample[name] = float(rng.uniform(spec[\"low\"], spec[\"high\"]))\n        elif t == \"int\":\n            sample[name] = int(rng.integers(spec[\"low\"], spec[\"high\"] + 1))\n        elif t == \"categorical\":\n            sample[name] = rng.choice(spec[\"choices\"])\n        else:\n            raise ValueError(f\"Unknown search-space type {t!r} for parameter {name!r}\")\n    return sample\n\n\ndef _encode_x(sample: Dict, space: Dict) -\u003e List[float]:\n    \"\"\"Encode *sample* into [0,1]\u207f for the surrogate models.\"\"\"\n    vec: List[float] = []\n    for name, spec in space.items():\n        val = sample[name]\n        t = spec[\"type\"].lower()\n        if t == \"loguniform\":\n            low, high = math.log10(spec[\"low\"]), math.log10(spec[\"high\"])\n            val = math.log10(val)\n            vec.append((val - low) / (high - low))\n        elif t in {\"uniform\", \"int\"}:\n            low, high = spec[\"low\"], spec[\"high\"]\n            vec.append((float(val) - low) / (high - low))\n        elif t == \"categorical\":\n            idx = spec[\"choices\"].index(val)\n            vec.append(idx / (len(spec[\"choices\"]) - 1))\n        else:\n            raise ValueError(t)\n    return vec\n\n###############################################################################\n#                            One training run                                 #\n###############################################################################\n\ndef _train_once(\n    sample: Dict,\n    cfg: DictConfig,\n    device: torch.device,\n    trial_mode: bool,\n    wb_run: wandb.sdk.wandb_run.Run,\n    step_offset: int,\n) -\u003e Tuple[float, float, Dict]:\n    \"\"\"Train a network with *sample* hyper-parameters.\n\n    Returns\n    -------\n    best_val_acc : float\n    wall_time    : float     \u2013 seconds\n    best_state   : Dict      \u2013 *state_dict* of network at best epoch\n    \"\"\"\n    start = time.perf_counter()\n\n    # ------------------------------------------------------------------\n    # 1) Build a *local* (deep-copied) cfg containing the sampled values\n    # ------------------------------------------------------------------\n    cfg_local = OmegaConf.to_container(cfg, resolve=True)\n    cfg_local = DictConfig(deepcopy(cfg_local))  # make it editable recursively\n\n    cfg_local.model.hidden_units = int(sample[\"hidden_units\"])\n    cfg_local.training.learning_rate = float(sample[\"learning_rate\"])\n\n    budget_iter = int(sample[\"training_iteration_budget\"])\n    epochs = 1 if trial_mode else int(budget_iter * cfg.training.epochs_per_iteration)\n\n    # Data ----------------------------------------------------------------\n    train_loader, val_loader, _ = get_dataloaders(cfg.dataset, cfg.training)\n\n    # Model / optim -------------------------------------------------------\n    model = build_model(cfg_local.model).to(device)\n    criterion = torch.nn.CrossEntropyLoss()\n    optimizer = torch.optim.Adam(model.parameters(), lr=cfg_local.training.learning_rate)\n\n    best_val_acc = 0.0\n    best_state: Dict = {}\n    global_step = step_offset\n\n    # --------------------------------------------------------------------\n    # Training loop\n    # --------------------------------------------------------------------\n    for epoch in range(1, epochs + 1):\n        model.train()\n        running_loss, correct, total = 0.0, 0, 0\n        for batch_idx, (images, labels) in enumerate(train_loader, 1):\n            images, labels = images.to(device), labels.to(device)\n            optimizer.zero_grad()\n            outputs = model(images)\n            loss = criterion(outputs, labels)\n            loss.backward()\n            optimizer.step()\n\n            running_loss += loss.item() * labels.size(0)\n            preds = outputs.argmax(dim=1)\n            correct += (preds == labels).sum().item()\n            total += labels.size(0)\n\n            # per-batch logging (verbose) --------------------------------\n            wb_run.log({\n                \"phase\": \"train\",\n                \"batch_loss\": loss.item(),\n                \"batch_idx\": batch_idx,\n                \"epoch\": epoch,\n            }, step=global_step)\n            global_step += 1\n\n            # trial-mode \u2014\u003e only 2 batches --------------------------------\n            if trial_mode and batch_idx \u003e= 2:\n                break\n\n        train_loss = running_loss / max(total, 1)\n        train_acc = correct / max(total, 1)\n\n        # --------------------- validation ------------------------------\n        model.eval()\n        val_loss, val_correct, val_total = 0.0, 0, 0\n        with torch.no_grad():\n            for images, labels in val_loader:\n                images, labels = images.to(device), labels.to(device)\n                outputs = model(images)\n                loss = criterion(outputs, labels)\n                val_loss += loss.item() * labels.size(0)\n                val_correct += (outputs.argmax(1) == labels).sum().item()\n                val_total += labels.size(0)\n        val_loss /= max(val_total, 1)\n        val_acc = val_correct / max(val_total, 1)\n\n        if val_acc \u003e best_val_acc:\n            best_val_acc = val_acc\n            best_state = deepcopy(model.state_dict())\n\n        # ------------------------ WandB ---------------------------------\n        wb_run.log({\n            \"epoch\": epoch,\n            \"train_loss\": train_loss,\n            \"train_acc\": train_acc,\n            \"val_loss\": val_loss,\n            \"val_acc\": val_acc,\n            \"hyper/learning_rate\": cfg_local.training.learning_rate,\n            \"hyper/hidden_units\": cfg_local.model.hidden_units,\n            \"hyper/budget_epochs\": epochs,\n        }, step=global_step)\n\n        # trial-mode \u2013 single epoch only -------------------------------\n        if trial_mode:\n            break\n\n    wall_time = time.perf_counter() - start\n    return best_val_acc, wall_time, best_state\n\n###############################################################################\n#                                 Main                                        #\n###############################################################################\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=None)\ndef main(cfg: DictConfig) -\u003e None:  # noqa: C901 \u2013 complexity unavoidable\n    # ------------------------------------------------------------------\n    # Trial-mode adjustments (should be *lightweight*)\n    # ------------------------------------------------------------------\n    if cfg.trial_mode:\n        cfg.wandb.mode = \"disabled\"\n        cfg.experiment.total_evaluations = 1\n        cfg.experiment.n_init_points = 1\n        cfg.training.epochs_per_iteration = 1\n        cfg.optuna.n_trials = 0\n\n    # ------------------------------------------------------------------\n    # Directories \u0026 WandB initialisation\n    # ------------------------------------------------------------------\n    out_dir = Path(hydra.utils.to_absolute_path(cfg.results_dir)) / cfg.run.run_id\n    out_dir.mkdir(parents=True, exist_ok=True)\n\n    # Save **resolved** Hydra config for provenance\n    OmegaConf.save(cfg, out_dir / \"config.yaml\")\n\n    wb_run = wandb.init(\n        mode=cfg.wandb.mode,\n        entity=cfg.wandb.entity,\n        project=cfg.wandb.project,\n        id=cfg.run.run_id,\n        dir=str(out_dir),\n        resume=\"allow\",\n        config=OmegaConf.to_container(cfg, resolve=True),\n    )\n    if wb_run.mode != \"disabled\":\n        print(f\"[WandB] URL: {wb_run.url}\")\n\n    device = torch.device(cfg.training.device if torch.cuda.is_available() else \"cpu\")\n\n    # ------------------------------------------------------------------\n    # BOIL / S-BOIL loop\n    # ------------------------------------------------------------------\n    space = cfg.optuna.search_space\n    rng = np.random.default_rng(seed=42)\n\n    X_enc: List[List[float]] = []   # encoded configuration vectors\n    Y: List[float] = []             # best validation acc per eval\n    costs: List[float] = []         # wall-clock seconds per eval\n    samples: List[Dict] = []        # actual sampled hyper-param dicts\n\n    best_global = -1.0\n    best_state: Dict = {}\n\n    for eval_id in range(cfg.experiment.total_evaluations):\n        # --------------------------------------------------------------\n        # Suggest next configuration\n        # --------------------------------------------------------------\n        if eval_id \u003c cfg.experiment.n_init_points:\n            sample = _sample_from_space(space, rng)\n        else:\n            # Fit accuracy surrogate ------------------------------------------------\n            X_t = torch.tensor(X_enc, dtype=torch.double)\n            Y_t = torch.tensor(Y, dtype=torch.double).unsqueeze(-1)\n            gp = SingleTaskGP(X_t, Y_t)\n            mll = ExactMarginalLogLikelihood(gp.likelihood, gp)\n            fit_gpytorch_model(mll)\n            best_y = max(Y)\n\n            # Cost surrogate (log-seconds) ----------------------------------------\n            lr_cost = LinearRegression().fit(np.array(X_enc), np.log(np.array(costs) + 1e-8))\n\n            # Evaluate acquisition on a random candidate set ----------------------\n            candidate_pool = [_sample_from_space(space, rng) for _ in range(512)]\n            X_pool = torch.tensor([_encode_x(s, space) for s in candidate_pool], dtype=torch.double)\n            posterior = gp.posterior(X_pool)\n            mu, var = posterior.mean.squeeze(-1), posterior.variance.squeeze(-1)\n            sigma = var.clamp_min(1e-12).sqrt()\n            # Expected Improvement (analytical)\n            z = (mu - best_y) / sigma\n            norm = torch.distributions.Normal(torch.zeros_like(z), torch.ones_like(z))\n            ei = (mu - best_y) * norm.cdf(z) + sigma * norm.log_prob(z).exp()\n            ei = ei.clamp_min(1e-12)\n\n            # Predicted cost -------------------------------------------------------\n            cost_pred = np.exp(lr_cost.predict(X_pool.cpu().numpy()))\n            cost_pred = torch.from_numpy(cost_pred).double().clamp_min(1e-6)\n\n            if cfg.experiment.acquisition.lower() == \"boil\":\n                acquisition = torch.log(ei) - torch.log(cost_pred)\n            elif cfg.experiment.acquisition.lower() == \"s-boil\":\n                betas = torch.tensor([\n                    s.get(\"beta\", cfg.experiment.beta_default) for s in candidate_pool\n                ], dtype=torch.double, device=ei.device)\n                acquisition = torch.log(ei) - betas * var - torch.log(cost_pred)\n            else:\n                raise ValueError(f\"Unknown acquisition kind {cfg.experiment.acquisition}\")\n\n            sample = candidate_pool[int(torch.argmax(acquisition).item())]\n\n        # --------------------------------------------------------------\n        # Evaluate the chosen configuration\n        # --------------------------------------------------------------\n        wb_run.log({f\"suggested/{k}\": v for k, v in sample.items()}, step=eval_id)\n        val_acc, wall_time, best_state_local = _train_once(\n            sample, cfg, device, cfg.trial_mode, wb_run, step_offset=eval_id * 10_000  # separate step ranges\n        )\n\n        X_enc.append(_encode_x(sample, space))\n        Y.append(val_acc)\n        costs.append(wall_time)\n        samples.append(sample)\n\n        wb_run.log({\n            \"evaluation_id\": eval_id,\n            \"val_acc\": val_acc,\n            \"wall_time\": wall_time,\n            \"best_val_acc_so_far\": max(Y),\n        }, step=(eval_id + 1) * 10_000)\n\n        if val_acc \u003e best_global:\n            best_global = val_acc\n            best_state = deepcopy(best_state_local)\n            wb_run.summary[\"best_val_accuracy\"] = best_global\n\n        # First time \u003e=80 %? -------------------------------------------------------\n        if val_acc \u003e= 0.8 and \"time_to_target\" not in wb_run.summary:\n            wb_run.summary[\"time_to_target\"] = float(sum(costs))\n            wb_run.summary[\"evals_to_target\"] = eval_id + 1\n\n        # Trial-mode \u2192 single evaluation only -------------------------------------\n        if cfg.trial_mode:\n            break\n\n    wb_run.summary[\"total_wall_time\"] = float(sum(costs))\n\n    # ----------------------------------------------------------------------\n    # Persist *globally* best network weights for later confusion matrix\n    # ----------------------------------------------------------------------\n    if best_state:\n        torch.save(best_state, out_dir / \"best_model.pt\")\n        wb_run.save(str(out_dir / \"best_model.pt\"), base_path=str(out_dir))\n\n    wandb.finish()\n\n\nif __name__ == \"__main__\":\n    main()\n"}

Analyze the experiment code thoroughly. Ensure it is complete, executable, and ready for publication-quality research experiments.
Output:
{
    "is_code_ready": false,
    "code_issue": "evaluate.py contains multiple blocking defects: (1) it tries to create a Dict object via `cfg = Dict(run_cfg)` – `typing.Dict` is not callable, leading to a TypeError; (2) the local variable name `stats` (loop variable over aggregated values) shadows the imported scipy.stats module, so the subsequent call to `stats.ttest_ind` will raise an AttributeError; (3) after (1) `cfg` remains a plain dict and is passed to get_dataloaders which expects an object with attribute access (`ds_cfg.name`, `train_cfg.batch_size`), causing an AttributeError. These faults make the evaluation script crash, violating the “complete implementation” criterion and preventing independent execution. All other core requirements rely on evaluate.py working, so the code is not production-ready yet."
}
