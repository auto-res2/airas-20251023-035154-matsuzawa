
LLM Name: o3-2025-04-16
Input:
You are a cutting-edge AI researcher generating complete, executable code for research paper experiments with Hydra configuration management.

Based on the research method in # Current Research Method and experimental design in # Experimental Design, generate production-ready experiment code that integrates with Hydra for configuration management.

# Instructions: Complete Experiment Code Generation

## Core Requirements
- COMPLETE IMPLEMENTATION: Every component must be fully functional, production-ready, publication-worthy code. No "omitted for brevity", no "simplified version", no TODO, PLACEHOLDER, pass, or ...
- PYTORCH EXCLUSIVELY: Use PyTorch as the deep learning framework
- HYDRA INTEGRATION: Use Hydra to manage all experiment configurations from `config/run/*.yaml` files. Use `config_path="../config"` in all @hydra.main decorators
- COMPLETE DATA PIPELINE: Full data loading and preprocessing implementation. Use `.cache/` as the cache directory for all datasets and models (e.g., for HuggingFace, set `cache_dir=".cache/"`)
- WANDB REQUIRED: WandB is mandatory for metrics logging (except trial_mode validation)

## Hydra Configuration Structure
Each run config file (`config/run/{run_id}.yaml`) contains:
- run_id: Unique identifier for this run
- method: The method name (baseline, proposed, ablation, etc.)
- model: Model-specific parameters (name, architecture details, hyperparameters)
- dataset: Dataset-specific parameters (name, preprocessing settings, split ratios)
- training: Training hyperparameters (learning rate, batch size, epochs, optimizer settings, validation split)
- optuna: Hyperparameter search space definition for Optuna optimization

## Command Line Interface
The generated code must support the following CLI:

**Training (main.py):**
```bash
# Full experiment with WandB logging
uv run python -u -m src.main run={run_id} results_dir={path} wandb.mode=online

# Trial mode (validation only, WandB disabled)
uv run python -u -m src.main run={run_id} results_dir={path} trial_mode=true
```
- `run`: Experiment run_id (matching a run_id from config/run/*.yaml)
- `results_dir`: Output directory (passed from GitHub Actions workflow)
- `trial_mode=true` (optional): Lightweight execution for validation (epochs=1, batches limited to 1-2, disable Optuna n_trials=0)
  * **When trial_mode=true, code must automatically set wandb.mode=disabled internally (e.g., `if cfg.trial_mode: cfg.wandb.mode = "disabled"`)**

**Evaluation (evaluate.py, independent execution):**
```bash
uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2", ...]'
```
- `results_dir`: Directory containing experiment metadata and where outputs will be saved
- `run_ids`: JSON string list of run IDs to evaluate (e.g., '["run-1-proposed-bert-glue", "run-2-baseline-bert-glue"]')
- Executed as a separate workflow after all training runs complete
- **NOT called from main.py**

## Script Structure (ExperimentCode format)
Generate complete code for these files ONLY. Do not create any additional files beyond this structure:

**`src/train.py`**: Single experiment run executor
- Uses Hydra config to load all parameters
- Called as subprocess by main.py
- Responsibilities:
  * Train model with given configuration
  * Initialize WandB: `wandb.init(entity=cfg.wandb.entity, project=cfg.wandb.project, id=cfg.run.run_id, config=OmegaConf.to_container(cfg, resolve=True), resume="allow")`
  * Skip `wandb.init()` if `cfg.wandb.mode == "disabled"` (trial_mode)
  * **Log ALL metrics to WandB comprehensively**:
    - Use `wandb.log()` at each training step/batch/epoch with ALL relevant metrics
    - Log as frequently as possible (per-batch or per-epoch) to capture training dynamics
  * **Save final/best metrics to WandB summary**:
    - Use `wandb.summary["key"] = value` for final results
  * Print WandB run URL to stdout
- **NO results.json, no stdout JSON output, no figure generation**

**`src/evaluate.py`**: Independent evaluation and visualization script
- **Execution**: Run independently via `uv run python -m src.evaluate results_dir={path} run_ids='["run-1", "run-2"]'`
- **NOT called from main.py** - executes as separate workflow after all training completes
- **Responsibilities**:
  * Parse command line arguments:
    - `results_dir`: Output directory path
    - `run_ids`: JSON string list of run IDs (parse with `json.loads(args.run_ids)`)
  * Load WandB config from `{results_dir}/config.yaml`
  * **Retrieve comprehensive experimental data from WandB API** for specified run_ids:
    ```python
    import json
    api = wandb.Api()
    run_ids = json.loads(args.run_ids)  # Parse JSON string to list
    for run_id in run_ids:
        run = api.run(f"{entity}/{project}/{run_id}")
        history = run.history()  # pandas DataFrame with ALL time-series metrics (train_loss, val_acc, etc.)
        summary = run.summary._json_dict  # Final/best metrics (best_val_acc, final_test_acc, etc.)
        config = dict(run.config)  # Run configuration (hyperparameters, model settings, etc.)
    ```
  * **STEP 1: Per-Run Processing** (for each run_id):
    - Export **comprehensive** run-specific metrics to: `{results_dir}/{run_id}/metrics.json`
    - Generate run-specific figures (learning curves, confusion matrices) to: `{results_dir}/{run_id}/`
    - Each run should have its own subdirectory with its metrics and figures
  * **STEP 2: Aggregated Analysis** (after processing all runs):
    - Export aggregated metrics to: `{results_dir}/comparison/aggregated_metrics.json`
    - Compute secondary/derived metrics (e.g., improvement rate: (proposed - baseline) / baseline)
    - Generate comparison figures to: `{results_dir}/comparison/`:
      * Cross-run comparison charts (bar charts, box plots)
      * Performance metrics tables
      * Statistical significance tests
  * **Figure Generation Guidelines**:
    - Use matplotlib or seaborn with proper legends, annotations, tight_layout
    - For line graphs: annotate significant values (final/best values)
    - For bar graphs: annotate values above each bar
    - Use GLOBALLY UNIQUE image filenames to prevent collisions across different runs and directories**:
      * Per-run figures: `{run_id}_{figure_topic}[_<condition>][_pairN].pdf` (e.g., `run-1-proposed-bert-glue_learning_curve.pdf`)
      * Comparison figures: `comparison_{figure_topic}[_<condition>][_pairN].pdf` (e.g., `comparison_accuracy_bar_chart.pdf`)
  * Print all generated file paths to stdout (both per-run and comparison)

**`src/preprocess.py`**: Complete preprocessing pipeline implementation for the specified datasets

**`src/model.py`**: Complete model architecture implementations for all methods (proposed and comparative methods)

**`src/main.py`**: Main orchestrator
- Receives run_id via Hydra, launches train.py as subprocess, manages logs
- **DOES NOT call evaluate.py** (evaluate.py runs independently in separate workflow)
- Use `@hydra.main(config_path="../config")` since execution is from repository root
- **Trial mode handling**: When `cfg.trial_mode=true`, automatically set `cfg.wandb.mode="disabled"` before any WandB operations

**`config/config.yaml`**: Main Hydra configuration file
- MUST include WandB configuration:
  ```yaml
  wandb:
    entity: gengaru617-personal
    project: 251023-test
    mode: online  # Automatically set to "disabled" in trial_mode
  ```
- `WANDB_API_KEY` environment variable is automatically available for authentication

**`pyproject.toml`**: Complete project dependencies
- MUST include: `hydra-core`, `wandb` (required)
- Include as needed: `optuna`, `torch`, `transformers`, `datasets`, etc.


## Key Implementation Focus Areas
1. **Hydra-Driven Configuration**: All parameters loaded from run configs dynamically
2. **Algorithm Core**: Full implementation of the proposed method with proper abstraction
3. **Trial Mode Behavior**: When `trial_mode=true`, code must automatically set `cfg.wandb.mode="disabled"` internally
4. **Run Execution**: main.py executes a single run_id passed via CLI (GitHub Actions dispatches multiple runs separately)
5. **WandB Integration**: All metrics logged to WandB; train.py does NOT output JSON to stdout or save results.json
6. **Independent Evaluation**: evaluate.py runs separately, fetches data from WandB API, generates all figures



## Code Validation Feedback


**Previous Validation Issue**: The package violates several mandatory requirements:

1. Evaluation script is broken
   • Reads “config.yaml” with json.load() although the file is YAML → runtime crash.
   • Depends on best_model.pt but train.py never saves the model.
   • Aggregated analysis is incomplete: no improvement-rate, no statistical tests, no box/ bar charts for all mandatory metrics.

2. Incomplete / placeholder code
   • train.py line 310: ‘best_sample = _sample_from_space(... )  # placeholder for merge’ – placeholder left in production code.

3. Trial-mode not fully honoured
   • Batch number / dataset size are not reduced to 1-2 batches; Optuna is only limited to 2 trials instead of 0.

4. Missing model persistence
   • No model checkpoint is written, yet evaluate.py expects it for confusion-matrix drawing.

5. Hydra / CLI mismatch
   • main.py launches “src.train” with overrides but never forwards ‘wandb.mode’; recommended interface from the spec is therefore unmet.

6. Required figures naming & analysis conventions not fully implemented (e.g. confusion-matrix, comparison_* names when cm_path is None, no unique pair suffix handling).

Because of the above issues the code will not execute successfully in its current form and is not publication-ready.
**Action Required**: Address this issue in the implementation.

**Previous Code (for reference)**:
{"config_yaml": "# config/config.yaml \u2013 top-level Hydra configuration\ndefaults:\n  - _self_\n\nrun:\n  run_id: default-run-id\n  method: placeholder\n\n# WandB logging\nwandb:\n  entity: gengaru617-personal\n  project: 251023-test\n  mode: online  # will be overridden to \"disabled\" automatically in trial_mode\n\n# General training configuration (overridden by run/* files)\nmodel:\n  name: dummy\n\ndataset:\n  name: dummy\n\ntraining:\n  batch_size: 64\n  device: cuda\n\noptuna:\n  n_trials: 1\n\nexperiment:\n  n_init_points: 1\n  total_evaluations: 1\n  acquisition: BOIL\n\n# CLI-controlled parameters ----------------------------------------------------\nresults_dir: outputs\ntrial_mode: false\n", "evaluate_py": "\"\"\"src/evaluate.py\nIndependent evaluation / visualisation script that runs after all\ntraining jobs have finished.  It pulls history \u0026 summary from WandB and\ncreates per-run as well as aggregated artefacts.\n\"\"\"\nfrom __future__ import annotations\n\nimport argparse\nimport json\nimport os\nimport statistics\nfrom pathlib import Path\nfrom typing import List\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nimport wandb\nfrom sklearn.metrics import ConfusionMatrixDisplay, confusion_matrix\n\nfrom .model import build_model\nfrom .preprocess import get_dataloaders\n\n\n######################################################################\n#                         Utility                                    #\n######################################################################\n\ndef _save_json(path: Path, obj):\n    path.parent.mkdir(parents=True, exist_ok=True)\n    with path.open(\"w\", encoding=\"utf-8\") as f:\n        json.dump(obj, f, indent=2, sort_keys=False)\n\n\ndef _plot_learning_curve(history_df, run_dir: Path, run_id: str):\n    plt.figure(figsize=(6, 4))\n    plt.plot(history_df[\"val_acc\"], label=\"Validation accuracy\")\n    plt.plot(history_df[\"train_acc\"], label=\"Training accuracy\", alpha=0.5)\n    plt.xlabel(\"Evaluation step\")\n    plt.ylabel(\"Accuracy\")\n    plt.title(f\"Learning curve \u2013 {run_id}\")\n    plt.legend()\n    plt.tight_layout()\n    fig_path = run_dir / f\"{run_id}_learning_curve.pdf\"\n    plt.savefig(fig_path)\n    plt.close()\n    return fig_path\n\n\ndef _plot_confusion(model_path: Path, cfg_path: Path, run_dir: Path, run_id: str):\n    import torch\n    from omegaconf import OmegaConf\n\n    if not model_path.exists():\n        return None\n\n    cfg = OmegaConf.load(cfg_path)\n    _, _, test_loader = get_dataloaders(cfg.dataset, cfg.training)\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n\n    model = build_model(cfg.model).to(device)\n    model.load_state_dict(torch.load(model_path, map_location=device))\n    model.eval()\n\n    all_preds, all_labels = [], []\n    with torch.no_grad():\n        for images, labels in test_loader:\n            images = images.to(device)\n            outputs = model(images)\n            preds = outputs.argmax(dim=1).cpu().numpy()\n            all_preds.append(preds)\n            all_labels.append(labels.numpy())\n    y_pred = np.concatenate(all_preds)\n    y_true = np.concatenate(all_labels)\n\n    cm = confusion_matrix(y_true, y_pred)\n    disp = ConfusionMatrixDisplay(cm)\n    disp.plot(cmap=\"Blues\")\n    plt.title(f\"Confusion Matrix \u2013 {run_id}\")\n    plt.tight_layout()\n    fig_path = run_dir / f\"{run_id}_confusion_matrix.pdf\"\n    plt.savefig(fig_path)\n    plt.close()\n    return fig_path\n\n######################################################################\n#                       Main evaluation                              #\n######################################################################\n\ndef main() -\u003e None:\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"results_dir\", type=str, help=\"Directory with training artefacts\")\n    parser.add_argument(\"run_ids\", type=str, help=\"JSON list of run-IDs to evaluate\")\n    args = parser.parse_args()\n\n    results_root = Path(args.results_dir).expanduser().resolve()\n    run_ids: List[str] = json.loads(args.run_ids)\n\n    cfg_global = json.load(open(results_root / run_ids[0] / \"config.yaml\"))\n    entity, project = cfg_global[\"wandb\"][\"entity\"], cfg_global[\"wandb\"][\"project\"]\n\n    api = wandb.Api()\n\n    aggregated_metrics = {}\n    per_run_paths = []\n\n    for rid in run_ids:\n        run_dir = results_root / rid\n        run_dir.mkdir(parents=True, exist_ok=True)\n\n        wb_run = api.run(f\"{entity}/{project}/{rid}\")\n        history = wb_run.history()  # pd.DataFrame\n        summary = wb_run.summary._json_dict\n        config = dict(wb_run.config)\n\n        # --- export raw metrics -------------------------------------------------\n        metrics_path = run_dir / \"metrics.json\"\n        _save_json(metrics_path, {\n            \"history\": history.to_dict(orient=\"list\"),\n            \"summary\": summary,\n            \"config\": config,\n        })\n\n        # --- figures -----------------------------------------------------------\n        lc_path = _plot_learning_curve(history, run_dir, rid)\n        cm_path = _plot_confusion(run_dir / \"best_model.pt\", run_dir / \"config.yaml\", run_dir, rid)\n\n        per_run_paths.extend([str(metrics_path), str(lc_path)] + ([str(cm_path)] if cm_path else []))\n\n        # store essential aggregated stats\n        aggregated_metrics[rid] = {\n            \"best_val_acc\": summary.get(\"best_val_accuracy\"),\n            \"wall_time_total\": summary.get(\"total_wall_time\"),\n            \"time_to_target\": summary.get(\"time_to_target\"),\n            \"evals_to_target\": summary.get(\"evals_to_target\"),\n        }\n\n    # ------------------- aggregated analysis ----------------------------------\n    comp_dir = results_root / \"comparison\"\n    comp_dir.mkdir(parents=True, exist_ok=True)\n\n    _save_json(comp_dir / \"aggregated_metrics.json\", aggregated_metrics)\n\n    # bar chart of best accuracy\n    plt.figure(figsize=(6, 4))\n    sns.barplot(x=list(aggregated_metrics.keys()),\n                y=[m[\"best_val_acc\"] for m in aggregated_metrics.values()])\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Best validation accuracy\")\n    plt.title(\"Best accuracy across runs\")\n    for i, val in enumerate(aggregated_metrics.values()):\n        plt.text(i, val[\"best_val_acc\"] + 0.005, f\"{val[\u0027best_val_acc\u0027]:.3f}\", ha=\"center\")\n    plt.tight_layout()\n    acc_bar_path = comp_dir / \"comparison_best_accuracy_bar_chart.pdf\"\n    plt.savefig(acc_bar_path)\n    plt.close()\n\n    per_run_paths.append(str(acc_bar_path))\n\n    # print all generated paths -------------------------------------------------\n    for p in per_run_paths:\n        print(p)\n\n\nif __name__ == \"__main__\":\n    main()\n", "main_py": "\"\"\"src/main.py\nOrchestrates a single run by forking a subprocess that executes\n``src.train`` with the appropriate Hydra overrides.\n\"\"\"\nfrom __future__ import annotations\n\nimport subprocess\nimport sys\nfrom pathlib import Path\nfrom typing import List\n\nimport hydra\nfrom omegaconf import DictConfig\n\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=None)\ndef main(cfg: DictConfig) -\u003e None:  # noqa: D401 \u2014 one-liner docstring not needed\n    # Convert config values to strings for cmd-line overrides\n    overrides: List[str] = [\n        f\"run={cfg.run.run_id}\",\n        f\"results_dir={cfg.results_dir}\",\n    ]\n    if cfg.trial_mode:\n        overrides.append(\"trial_mode=true\")\n\n    cmd = [sys.executable, \"-u\", \"-m\", \"src.train\", *overrides]\n    print(\"Launching:\", \" \".join(cmd))\n    subprocess.run(cmd, check=True)\n\n\nif __name__ == \"__main__\":\n    main()\n", "model_py": "\"\"\"src/model.py\nNetwork architecture definitions.\n\"\"\"\nfrom __future__ import annotations\n\nimport math\nfrom typing import Any\n\nimport torch\nimport torch.nn as nn\nfrom omegaconf import DictConfig\n\n\nclass TwoLayerMLP(nn.Module):\n    def __init__(self, input_dim: int, hidden_units: int, output_classes: int,\n                 activation: str = \"relu\", weight_init: str = \"kaiming_uniform\") -\u003e None:\n        super().__init__()\n        act_cls: Any = getattr(nn, activation.capitalize()) if hasattr(nn, activation.capitalize()) else nn.ReLU\n        self.net = nn.Sequential(\n            nn.Flatten(),\n            nn.Linear(input_dim, hidden_units),\n            act_cls(),\n            nn.Linear(hidden_units, output_classes),\n        )\n        self.apply(lambda m: self._init_weights(m, weight_init))\n\n    @staticmethod\n    def _init_weights(module: nn.Module, scheme: str):\n        if isinstance(module, nn.Linear):\n            if scheme == \"kaiming_uniform\":\n                nn.init.kaiming_uniform_(module.weight, nonlinearity=\"relu\")\n            elif scheme == \"kaiming_normal\":\n                nn.init.kaiming_normal_(module.weight, nonlinearity=\"relu\")\n            elif scheme == \"xavier_uniform\":\n                nn.init.xavier_uniform_(module.weight)\n            elif scheme == \"xavier_normal\":\n                nn.init.xavier_normal_(module.weight)\n            else:\n                raise ValueError(scheme)\n            if module.bias is not None:\n                nn.init.constant_(module.bias, 0)\n\n    def forward(self, x):  # noqa: D401  \u2013 one-liner docstring not necessary\n        return self.net(x)\n\n\n# -----------------------------------------------------------------------------\n#                               Factory                                         \n# -----------------------------------------------------------------------------\n\ndef build_model(model_cfg: DictConfig):\n    name = model_cfg.name.lower()\n    if name == \"two-layer-mlp-1.2m\":\n        return TwoLayerMLP(\n            input_dim=model_cfg.input_dim,\n            hidden_units=model_cfg.hidden_units,\n            output_classes=model_cfg.output_classes,\n            activation=model_cfg.activation,\n            weight_init=model_cfg.weight_init,\n        )\n    else:\n        raise NotImplementedError(name)\n", "preprocess_py": "\"\"\"src/preprocess.py\nData loading / preprocessing utilities.  Supports Fashion-MNIST only\nbut is written so that future datasets can be added easily.\n\"\"\"\nfrom __future__ import annotations\n\nfrom typing import Tuple\n\nimport torch\nimport torchvision.transforms as T\nfrom omegaconf import DictConfig\nfrom torch.utils.data import DataLoader, random_split\nfrom torchvision.datasets import FashionMNIST\n\n\ndef _parse_transforms(trans_list):\n    \"\"\"Convert a list of simple strings / dicts from YAML to torchvision ops.\"\"\"\n    ops = []\n    for item in trans_list:\n        if isinstance(item, str):\n            if item.lower() == \"totensor\":\n                ops.append(T.ToTensor())\n            else:\n                raise ValueError(item)\n        elif isinstance(item, dict):\n            # currently only Normalize supported\n            if \"Normalize\" in item:\n                mean = item[\"Normalize\"].get(\"mean\", 0.5)\n                std = item[\"Normalize\"].get(\"std\", 0.5)\n                ops.append(T.Normalize(mean=[mean], std=[std]))\n            else:\n                raise ValueError(item)\n        else:\n            raise TypeError(item)\n    return T.Compose(ops)\n\n\ndef get_dataloaders(ds_cfg: DictConfig, train_cfg: DictConfig) -\u003e Tuple[DataLoader, DataLoader, DataLoader]:\n    \"\"\"Return train, val, test PyTorch DataLoaders.\"\"\"\n    if ds_cfg.name.lower() != \"fashion-mnist\":\n        raise NotImplementedError(ds_cfg.name)\n\n    transform = _parse_transforms(ds_cfg.transforms)\n\n    root = \".cache/torchvision/fashion_mnist\"\n    train_full = FashionMNIST(root=root, train=True, download=True, transform=transform)\n    test_set = FashionMNIST(root=root, train=False, download=True, transform=transform)\n\n    val_split = ds_cfg.validation_split\n    val_size = int(len(train_full) * val_split)\n    train_size = len(train_full) - val_size\n    train_set, val_set = random_split(train_full, [train_size, val_size])\n\n    loader_kwargs = {\n        \"batch_size\": train_cfg.batch_size,\n        \"num_workers\": train_cfg.num_workers,\n        \"pin_memory\": train_cfg.pin_memory,\n    }\n    train_loader = DataLoader(train_set, shuffle=True, **loader_kwargs)\n    val_loader = DataLoader(val_set, shuffle=False, **loader_kwargs)\n    test_loader = DataLoader(test_set, shuffle=False, **loader_kwargs)\n\n    return train_loader, val_loader, test_loader\n", "pyproject_toml": "[build-system]\nrequires = [\"setuptools\u003e=61.0\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"s-boil-experiment\"\nversion = \"0.1.0\"\ndependencies = [\n  \"torch\u003e=2.0\",              # PyTorch core\n  \"torchvision\u003e=0.15\",       # datasets + transforms\n  \"botorch\u003e=0.8.5\",          # GP + BO utils\n  \"gpytorch\u003e=1.11\",          # underlying GP library\n  \"hydra-core\u003e=1.3\",         # configuration management\n  \"wandb\u003e=0.15\",             # experiment tracking\n  \"optuna\u003e=3.4\",             # (search-space definitions)\n  \"scikit-learn\u003e=1.3\",       # linear regression + metrics\n  \"matplotlib\u003e=3.7\",         # plotting\n  \"seaborn\u003e=0.12\",           # prettier plots\n  \"pandas\u003e=2.0\",             # WandB history DataFrame manipulation\n  \"numpy\u003e=1.24\",             # numerical utils\n]\n\n[tool.setuptools.packages.find]\nwhere = [\"src\"]\n", "train_py": "\"\"\"src/train.py\nTrainer script executing a single hyper-parameter optimisation run.\nThis file must be executed through Hydra so that the full configuration\nis available under ``cfg``.  All heavy-lifting \u2013 data loading, model\nconstruction, BOIL / S-BOIL loop, wandb logging \u2013 happens here.\n\"\"\"\nfrom __future__ import annotations\n\nimport json\nimport math\nimport os\nimport subprocess\nimport sys\nimport time\nfrom pathlib import Path\nfrom typing import Dict, List, Tuple\n\nimport hydra\nimport numpy as np\nimport torch\nfrom botorch.fit import fit_gpytorch_model\nfrom botorch.models import SingleTaskGP\nfrom gpytorch.mlls import ExactMarginalLogLikelihood\nfrom omegaconf import DictConfig, OmegaConf\nfrom sklearn.linear_model import LinearRegression\nfrom torch import Tensor\n\nimport wandb\n\nfrom .model import build_model\nfrom .preprocess import get_dataloaders\n\n######################################################################\n#                       Utility helpers                              #\n######################################################################\n\ndef _log_uniform_sample(low: float, high: float, rng: np.random.Generator) -\u003e float:\n    return float(10 ** rng.uniform(np.log10(low), np.log10(high)))\n\n\ndef _sample_from_space(search_space: Dict, rng: np.random.Generator) -\u003e Dict:\n    \"\"\"Draw a random sample from an Optuna-style search-space dict.\"\"\"\n    sample: Dict = {}\n    for name, spec in search_space.items():\n        typ = spec[\"type\"].lower()\n        if typ == \"loguniform\":\n            sample[name] = _log_uniform_sample(spec[\"low\"], spec[\"high\"], rng)\n        elif typ == \"uniform\":\n            sample[name] = float(rng.uniform(spec[\"low\"], spec[\"high\"]))\n        elif typ == \"int\":\n            sample[name] = int(rng.integers(spec[\"low\"], spec[\"high\"] + 1))\n        elif typ == \"categorical\":\n            sample[name] = rng.choice(spec[\"choices\"])\n        else:\n            raise ValueError(f\"Unknown search-space type: {typ}\")\n    return sample\n\n\ndef _encode_x(sample: Dict, search_space: Dict) -\u003e List[float]:\n    \"\"\"Encode a configuration *sample* into a normalised numeric list in [0,1].\"\"\"\n    vec: List[float] = []\n    for name, spec in search_space.items():\n        val = sample[name]\n        typ = spec[\"type\"].lower()\n        if typ == \"loguniform\":  # work in log\u2081\u2080 domain\n            low, high = math.log10(spec[\"low\"]), math.log10(spec[\"high\"])\n            val = math.log10(val)\n            vec.append((val - low) / (high - low))\n        elif typ in {\"uniform\", \"int\"}:\n            low, high = spec[\"low\"], spec[\"high\"]\n            vec.append((float(val) - low) / (high - low))\n        elif typ == \"categorical\":\n            # ordinal encode according to index in list\n            idx = spec[\"choices\"].index(val)\n            high = len(spec[\"choices\"]) - 1\n            vec.append(idx / high)\n        else:\n            raise ValueError(typ)\n    return vec\n\n\ndef _build_gp(X: Tensor, Y: Tensor) -\u003e SingleTaskGP:\n    gp = SingleTaskGP(X, Y)\n    mll = ExactMarginalLogLikelihood(gp.likelihood, gp)\n    fit_gpytorch_model(mll)\n    return gp\n\n\ndef _expected_improvement(mu: Tensor, sigma: Tensor, best: float) -\u003e Tensor:\n    \"\"\"Analytical EI; mu/sigma shape (*,1).  Returns same shape.\"\"\"\n    sigma = sigma.clamp_min(1e-9)\n    u = (mu - best) / sigma\n    normal = torch.distributions.Normal(torch.tensor(0.0, device=mu.device),\n                                        torch.tensor(1.0, device=mu.device))\n    ei = (mu - best) * normal.cdf(u) + sigma * normal.log_prob(u).exp()\n    return ei.clamp_min(0.0)\n\n######################################################################\n#                          Training loop                             #\n######################################################################\n\ndef _train_once(sample: Dict, cfg: DictConfig, device: torch.device,\n                global_step: int, wb_run: wandb.sdk.wandb_run.Run) -\u003e Tuple[float, float]:\n    \"\"\"Train model for one BO evaluation.  Returns (val_acc, wall_time).\"\"\"\n    start = time.perf_counter()\n\n    # Update cfg with the hyper-parameters we evaluate this round\n    cfg_local = OmegaConf.create(OmegaConf.to_container(cfg, resolve=True))  # deep copy\n    cfg_local.model.hidden_units = int(sample[\"hidden_units\"])\n    cfg_local.training.learning_rate = float(sample[\"learning_rate\"])\n    budget = int(sample[\"training_iteration_budget\"])\n    epochs = int(budget * cfg.training.epochs_per_iteration)\n\n    train_loader, val_loader, _ = get_dataloaders(cfg.dataset, cfg.training)\n\n    model = build_model(cfg_local.model).to(device)\n    criterion = torch.nn.CrossEntropyLoss()\n    optimizer = torch.optim.Adam(model.parameters(), lr=cfg_local.training.learning_rate)\n\n    best_val_acc = 0.0\n\n    for epoch in range(1, epochs + 1):\n        model.train()\n        total, correct, running_loss = 0, 0, 0.0\n        for images, labels in train_loader:\n            images, labels = images.to(device), labels.to(device)\n            optimizer.zero_grad()\n            outputs = model(images)\n            loss = criterion(outputs, labels)\n            loss.backward()\n            optimizer.step()\n            running_loss += loss.item() * labels.size(0)\n            _, preds = torch.max(outputs, 1)\n            total += labels.size(0)\n            correct += (preds == labels).sum().item()\n        train_loss = running_loss / total\n        train_acc = correct / total\n\n        # Validation\n        model.eval()\n        total_v, correct_v, val_loss_tot = 0, 0, 0.0\n        with torch.no_grad():\n            for images, labels in val_loader:\n                images, labels = images.to(device), labels.to(device)\n                outputs = model(images)\n                loss = criterion(outputs, labels)\n                val_loss_tot += loss.item() * labels.size(0)\n                _, preds = torch.max(outputs, 1)\n                total_v += labels.size(0)\n                correct_v += (preds == labels).sum().item()\n        val_loss = val_loss_tot / total_v\n        val_acc = correct_v / total_v\n        best_val_acc = max(best_val_acc, val_acc)\n\n        # log to wandb\n        metrics = {\n            \"step\": global_step,\n            \"epoch\": epoch,\n            \"train_loss\": train_loss,\n            \"train_acc\": train_acc,\n            \"val_loss\": val_loss,\n            \"val_acc\": val_acc,\n            \"hyperparams/learning_rate\": cfg_local.training.learning_rate,\n            \"hyperparams/hidden_units\": cfg_local.model.hidden_units,\n            \"hyperparams/budget_epochs\": epochs,\n        }\n        wb_run.log(metrics)\n\n    wall_time = time.perf_counter() - start\n    return best_val_acc, wall_time\n\n######################################################################\n#                           Main entry                               #\n######################################################################\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=None)\ndef train(cfg: DictConfig) -\u003e None:  # noqa: C901  -- complexity unavoidable\n    # ------------------------------------------------------------------\n    # Trial-mode overrides (lightweight CI runs)\n    # ------------------------------------------------------------------\n    if cfg.trial_mode:\n        cfg.wandb.mode = \"disabled\"\n        cfg.optuna.n_trials = 2\n        cfg.experiment.total_evaluations = 2\n        cfg.training.epochs_per_iteration = 1\n\n    # ------------------------------------------------------------------\n    # Prepare output directory and WandB initialisation\n    # ------------------------------------------------------------------\n    root_output = Path(hydra.utils.to_absolute_path(cfg.results_dir)) / cfg.run.run_id\n    root_output.mkdir(parents=True, exist_ok=True)\n\n    # Save *resolved* configuration for later inspection / evaluation\n    OmegaConf.save(cfg, root_output / \"config.yaml\")\n\n    if cfg.wandb.mode != \"disabled\":\n        wb_run = wandb.init(\n            entity=cfg.wandb.entity,\n            project=cfg.wandb.project,\n            id=cfg.run.run_id,\n            dir=str(root_output),\n            config=OmegaConf.to_container(cfg, resolve=True),\n            resume=\"allow\",\n            mode=cfg.wandb.mode,\n        )\n        print(f\"WandB URL: {wb_run.url}\")\n    else:\n        wb_run = wandb.init(mode=\"disabled\")\n\n    device = torch.device(cfg.training.device if torch.cuda.is_available() else \"cpu\")\n\n    # ------------------------------------------------------------------\n    # BOIL / S-BOIL optimisation loop\n    # ------------------------------------------------------------------\n    search_space = cfg.optuna.search_space\n    rng = np.random.default_rng(seed=42)\n    n_init = cfg.experiment.n_init_points\n    total_evals = cfg.experiment.total_evaluations\n\n    X_list: List[List[float]] = []  # encoded\n    Y_list: List[float] = []        # val acc\n    cost_list: List[float] = []     # wall time\n\n    global_step = 0\n\n    for eval_id in range(total_evals):\n        # --------------------------------------------------------------\n        # Suggest next configuration\n        # --------------------------------------------------------------\n        if eval_id \u003c n_init:\n            # random initial design\n            sample = _sample_from_space(search_space, rng)\n        else:\n            # fit surrogate models\n            X_tensor = torch.tensor(X_list, dtype=torch.double)\n            Y_tensor = torch.tensor(Y_list, dtype=torch.double).unsqueeze(-1)\n            gp = _build_gp(X_tensor, Y_tensor)\n            best_y = max(Y_list)\n\n            # Linear regression for cost (log-cost)\n            lr_model = LinearRegression().fit(np.asarray(X_list), np.log(np.asarray(cost_list) + 1e-8))\n\n            # Candidate set sampled randomly; acquisition computed for each\n            cand_samples = [_sample_from_space(search_space, rng) for _ in range(512)]\n            cand_X_enc = torch.tensor([_encode_x(s, search_space) for s in cand_samples], dtype=torch.double)\n            post = gp.posterior(cand_X_enc)\n            mu, var = post.mean.squeeze(-1), post.variance.squeeze(-1)\n            std = var.clamp_min(1e-9).sqrt()\n            ei = _expected_improvement(mu.unsqueeze(-1), std.unsqueeze(-1), best_y).squeeze(-1)\n\n            # cost prediction\n            cost_pred = np.exp(lr_model.predict(cand_X_enc.cpu().numpy()))\n            cost_pred = torch.from_numpy(cost_pred).double()\n\n            if cfg.experiment.acquisition.lower() == \"boil\":\n                acq = torch.log(ei + 1e-10) - torch.log(cost_pred + 0.1)\n            elif cfg.experiment.acquisition.lower() == \"s-boil\":\n                # beta per candidate if present else default\n                beta_vals = torch.tensor([s.get(\"beta\", cfg.experiment.beta_default) for s in cand_samples], dtype=torch.double)\n                acq = torch.log(ei + 1e-10) - beta_vals * var - torch.log(cost_pred + 0.1)\n            else:\n                raise ValueError(f\"Unknown acquisition {cfg.experiment.acquisition}\")\n\n            best_idx = int(torch.argmax(acq).item())\n            sample = cand_samples[best_idx]\n\n        # --------------------------------------------------------------\n        # Evaluate configuration (train network)\n        # --------------------------------------------------------------\n        cfg_sample = OmegaConf.merge(cfg, sample)  # for logging only\n        wb_run.log({f\"eval/{k}\": v for k, v in sample.items()}, step=global_step)\n        val_acc, wall_time = _train_once(sample, cfg, device, global_step, wb_run)\n\n        # Append observations\n        X_list.append(_encode_x(sample, search_space))\n        Y_list.append(val_acc)\n        cost_list.append(wall_time)\n\n        # Log evaluation-level metrics\n        wb_run.log({\n            \"eval_id\": eval_id,\n            \"val_acc\": val_acc,\n            \"wall_time\": wall_time,\n            \"best_val_acc_so_far\": max(Y_list),\n        }, step=global_step)\n        global_step += 1\n\n        # early record time-to-target\n        if val_acc \u003e= 0.8 and \"time_to_target\" not in wb_run.summary:\n            elapsed_total = sum(cost_list)\n            wb_run.summary[\"time_to_target\"] = elapsed_total\n            wb_run.summary[\"evals_to_target\"] = eval_id + 1\n\n    # ------------------------------------------------------------------\n    # Finish run \u2013 store best metrics and (optionally) model artefact\n    # ------------------------------------------------------------------\n    best_idx = int(np.argmax(Y_list))\n    best_sample = _sample_from_space(search_space, np.random.default_rng())  # placeholder for merge\n    best_sample.update({k: v for k, v in sample.items()})\n    wb_run.summary[\"best_val_accuracy\"] = float(Y_list[best_idx])\n    wb_run.summary[\"total_wall_time\"] = float(sum(cost_list))\n\n    wandb.finish()\n\nif __name__ == \"__main__\":\n    train()\n"}

Fix the issues identified above while preserving the correct parts of the implementation.



# Experimental Environment
NVIDIA A100×8
VRAM：80GB×8
RAM：2048 GB

# Current Research Method
{
    "Open Problems": "In BOIL, the acquisition score is obtained by dividing Expected-Improvement (EI) by an estimated cost coming from a simple linear regression.  However, EI is computed only from the GP predictive mean; it completely ignores the predictive variance of the final performance that the GP supplies.  As a consequence BOIL often proposes configurations whose *expected* gain is large but whose *uncertainty* is also large, leading to wasted wall-clock time on unstable or highly noisy runs.  A very small change that explicitly trades off improvement against predictive risk can reduce these wasted evaluations without touching the GP model, the curve-compression, or the selective data-augmentation machinery.",
    "Methods": "Stability-Aware Cost-Efficient BOIL (S-BOIL)\nMinimal change: multiply the utility part of BOIL’s cost-aware acquisition by an exponential penalty that depends on the GP’s predictive variance σ²(x,t) at the candidate (x,t):\n\n    Utility_s = EI(x,t) * exp(-β · σ²(x,t))\n    Acquisition  =  log(Utility_s)  –  log(EstimatedCost+0.1)\n\nwhere β≥0 is a single tunable constant (β≈1 works well).  Intuition: for equal EI, prefer points the GP is certain about; for equal variance, recover the original BOIL rule.  Because σ² is already returned by the GP, the only code change is three lines in the acquisition function.  No retraining or extra hyper-parameters are introduced apart from β.",
    "Experimental Setup": "Base method: original BOIL implementation.\nProposed: S-BOIL (β ∈ {0.5,1}).\nTask: tune two hyper-parameters (learning-rate, hidden-units) and the training-iteration budget for an MLP on the Fashion-MNIST 10-class task (using PyTorch).  Each BO run is allowed 30 real evaluations; wall-clock time is logged.\nMetrics:\n1. Best validation accuracy reached vs. number of real evaluations.\n2. Total wall-clock time until a target accuracy (80%) is hit.\nProtocol: 10 independent seeds for each method.  Same initial random design (3 points).",
    "Experimental Code": "# --- patch to BOIL: Stability penalty ------------------------------------\n# in utility_cost_evaluation_single() *replace* the EI computation line\n# original: utility = acq_func.acq_kind(x,gp=self.gp)\n# new lines:\nmean, var = self.gp.predict(x.reshape(1,-1), return_var=True)\nei_val  = acq_func.ei(mean, var, acq_func.best_y)   # unchanged helper\nutility = ei_val * np.exp(-beta * var)              # <- stability term\n# everything else stays the same\n# ----------------------------------------------------------\n\n# Minimal runnable demo (requires original BOIL code in path)\nimport torch, torchvision, torch.nn as nn, torch.optim as optim\nfrom boil import BOIL        # assume original class name\n\nbeta = 1.0  # stability weight\nbo = BOIL(func=mlp_runner, SearchSpace={\"lr\":(1e-4,1e-1),\n                                        \"units\":(64,512),\n                                        \"T\":(1,15)})\nbo.beta = beta               # pass to acquisition helper\nbo.init(n_init_points=3)\nfor _ in range(27):          # 30 evaluations total\n    bo.suggest_nextpoint()\nprint(\"Best acc =\", bo.Y_original.max())",
    "Expected Result": "Across 10 seeds S-BOIL is expected to reach 80% validation accuracy in ~15% less wall-clock time and 2 fewer function evaluations on average compared with BOIL.  The area-under-curve of best-seen accuracy vs. evaluations should also improve by ≈5–7%.",
    "Expected Conclusion": "A tiny, one-line modification that penalizes predictive variance lets BOIL avoid expensive yet uncertain configurations, giving faster convergence at virtually no additional computational cost or implementation complexity.  This demonstrates that explicitly accounting for GP uncertainty inside the acquisition utility—beyond its usual role in EI—is a simple but powerful way to improve efficiency in iterative hyperparameter optimization."
}

# Experimental Design
- Summary: The experiment aims to verify that the Stability-Aware Cost-Efficient BOIL (S-BOIL) acquisition rule accelerates hyper-parameter tuning compared with the original BOIL.  We run black-box optimisation on a two-layer MLP (≈1.2 M parameters) that is trained on Fashion-MNIST.  The optimiser must choose three configuration variables—learning-rate, hidden-units, and training-iteration budget—over 30 real training runs.  For each of 10 random seeds we execute (1) vanilla BOIL and (2) S-BOIL with a variance-penalised utility EI·exp(−βσ²).  β is treated as a small discrete hyper-parameter {0.5,1}.  All other code, GP surrogate, cost model, and initial design remain identical.  Metrics recorded at every function evaluation are: best-seen validation accuracy, wall-clock time, and the area-under-curve (AUC) of accuracy versus evaluations.  The primary comparisons are (i) mean evaluations and time to reach 80 % accuracy and (ii) mean AUAC across seeds.  The whole study fits comfortably on one A100 GPU, but eight are available if parallel seeds are desired.
- Evaluation metrics: ['Validation Accuracy', 'Wall-clock Time to Target', 'Area Under Accuracy Curve']

# Experiment Runs

- Run ID: proposed-Two-Layer-MLP-1.2M-Fashion-MNIST
  Method: proposed
  Model: Two-Layer-MLP-1.2M
  Dataset: Fashion-MNIST
  Config File: config/run/proposed-Two-Layer-MLP-1.2M-Fashion-MNIST.yaml
  
  Config Content:
  ```yaml
  run_id: proposed-Two-Layer-MLP-1.2M-Fashion-MNIST
method: S-BOIL
model:
  name: Two-Layer-MLP-1.2M
  input_dim: 784
  hidden_units: 256        # default, tuned via Optuna
  output_classes: 10
  activation: relu
  weight_init: kaiming_uniform
dataset:
  name: Fashion-MNIST
  transforms:
    - ToTensor
    - Normalize(mean=0.5, std=0.5)
  validation_split: 0.1
training:
  batch_size: 128
  optimizer: adam
  loss_fn: cross_entropy
  device: cuda
  default_learning_rate: 1e-3
  epochs_per_iteration: 5   # total epochs = budget * 5
  num_workers: 8
  pin_memory: true
experiment:
  n_init_points: 3
  total_evaluations: 30
  acquisition: S-BOIL       # log(EI*exp(-βσ²)) − log(cost)
  beta_default: 1.0
optuna:
  n_trials: 30
  direction: maximize
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-4
      high: 1e-1
    hidden_units:
      type: int
      low: 64
      high: 512
    training_iteration_budget:
      type: int
      low: 1
      high: 15
    beta:
      type: categorical
      choices: [0.5, 1.0]

  ```
  

- Run ID: comparative-1-Two-Layer-MLP-1.2M-Fashion-MNIST
  Method: comparative-1
  Model: Two-Layer-MLP-1.2M
  Dataset: Fashion-MNIST
  Config File: config/run/comparative-1-Two-Layer-MLP-1.2M-Fashion-MNIST.yaml
  
  Config Content:
  ```yaml
  run_id: comparative-1-Two-Layer-MLP-1.2M-Fashion-MNIST
method: BOIL
model:
  name: Two-Layer-MLP-1.2M
  input_dim: 784
  hidden_units: 256        # default, tuned via Optuna
  output_classes: 10
  activation: relu
  weight_init: kaiming_uniform
dataset:
  name: Fashion-MNIST
  transforms:
    - ToTensor
    - Normalize(mean=0.5, std=0.5)
  validation_split: 0.1
training:
  batch_size: 128
  optimizer: adam
  loss_fn: cross_entropy
  device: cuda
  default_learning_rate: 1e-3
  epochs_per_iteration: 5
  num_workers: 8
  pin_memory: true
experiment:
  n_init_points: 3
  total_evaluations: 30
  acquisition: BOIL         # log(EI) − log(cost)
optuna:
  n_trials: 30
  direction: maximize
  search_space:
    learning_rate:
      type: loguniform
      low: 1e-4
      high: 1e-1
    hidden_units:
      type: int
      low: 64
      high: 512
    training_iteration_budget:
      type: int
      low: 1
      high: 15

  ```
  


# External Resources (Use these for implementation)

**HuggingFace Models:**


**HuggingFace Datasets:**

- ID: zalando-datasets/fashion_mnist




Generate complete, production-ready experiment code that integrates with Hydra configuration system.
Output:
{
    "train_py": "\"\"\"src/train.py\nFull training script for one hyper-parameter-optimisation run (BOIL or\nS-BOIL).  This file must be executed through Hydra so that the complete\nconfiguration is available in ``cfg``.\n\nResponsibilities\n----------------\n1.  Draw the requested number of configurations (`cfg.experiment.*`) from\n    the search-space (`cfg.optuna.search_space`).  During the initial\n    phase (`n_init_points`) configurations are drawn uniformly at\n    random.  Afterwards we fit\n    • a single-task GP surrogate over best-seen validation accuracy and\n    • a linear-regression cost model over log-wall-time.\n\n    The acquisition function is either\n      BOIL    log(EI) − log(cost)                     or\n      S-BOIL log(EI) − β·σ² − log(cost)\n\n    where β is part of the candidate configuration (categorical) or, if\n    not present, `cfg.experiment.beta_default`.\n\n2.  For each suggested configuration we train **a full model** (or a very\n    small model in `trial_mode`) and log everything to WandB.\n\n3.  Persist the *globally* best model to ``best_model.pt`` so that the\n    evaluation script can draw a confusion matrix later on.\n\n4.  Honour *trial-mode* completely: one evaluation, one epoch, two\n    batches, no WandB traffic.\n\"\"\"\nfrom __future__ import annotations\n\nimport json\nimport math\nimport time\nfrom copy import deepcopy\nfrom pathlib import Path\nfrom typing import Dict, List, Tuple\n\nimport hydra\nimport numpy as np\nimport torch\nimport wandb\nfrom botorch.fit import fit_gpytorch_model\nfrom botorch.models import SingleTaskGP\nfrom gpytorch.mlls import ExactMarginalLogLikelihood\nfrom omegaconf import DictConfig, OmegaConf\nfrom sklearn.linear_model import LinearRegression\n\nfrom .model import build_model\nfrom .preprocess import get_dataloaders\n\n###############################################################################\n#                     Helper: sampling & encoding utilities                   #\n###############################################################################\n\ndef _log_uniform(low: float, high: float, rng: np.random.Generator) -> float:\n    \"\"\"Sample from a log-uniform distribution in base-10 space.\"\"\"\n    return float(10 ** rng.uniform(np.log10(low), np.log10(high)))\n\n\ndef _sample_from_space(space: Dict, rng: np.random.Generator) -> Dict:\n    \"\"\"Draw one random configuration from an Optuna-style *space* dict.\"\"\"\n    sample = {}\n    for name, spec in space.items():\n        t = spec[\"type\"].lower()\n        if t == \"loguniform\":\n            sample[name] = _log_uniform(spec[\"low\"], spec[\"high\"], rng)\n        elif t == \"uniform\":\n            sample[name] = float(rng.uniform(spec[\"low\"], spec[\"high\"]))\n        elif t == \"int\":\n            sample[name] = int(rng.integers(spec[\"low\"], spec[\"high\"] + 1))\n        elif t == \"categorical\":\n            sample[name] = rng.choice(spec[\"choices\"])\n        else:\n            raise ValueError(f\"Unknown search-space type {t!r} for parameter {name!r}\")\n    return sample\n\n\ndef _encode_x(sample: Dict, space: Dict) -> List[float]:\n    \"\"\"Encode *sample* into [0,1]ⁿ for the surrogate models.\"\"\"\n    vec: List[float] = []\n    for name, spec in space.items():\n        val = sample[name]\n        t = spec[\"type\"].lower()\n        if t == \"loguniform\":\n            low, high = math.log10(spec[\"low\"]), math.log10(spec[\"high\"])\n            val = math.log10(val)\n            vec.append((val - low) / (high - low))\n        elif t in {\"uniform\", \"int\"}:\n            low, high = spec[\"low\"], spec[\"high\"]\n            vec.append((float(val) - low) / (high - low))\n        elif t == \"categorical\":\n            idx = spec[\"choices\"].index(val)\n            vec.append(idx / (len(spec[\"choices\"]) - 1))\n        else:\n            raise ValueError(t)\n    return vec\n\n###############################################################################\n#                            One training run                                 #\n###############################################################################\n\ndef _train_once(\n    sample: Dict,\n    cfg: DictConfig,\n    device: torch.device,\n    trial_mode: bool,\n    wb_run: wandb.sdk.wandb_run.Run,\n    step_offset: int,\n) -> Tuple[float, float, Dict]:\n    \"\"\"Train a network with *sample* hyper-parameters.\n\n    Returns\n    -------\n    best_val_acc : float\n    wall_time    : float     – seconds\n    best_state   : Dict      – *state_dict* of network at best epoch\n    \"\"\"\n    start = time.perf_counter()\n\n    # ------------------------------------------------------------------\n    # 1) Build a *local* (deep-copied) cfg containing the sampled values\n    # ------------------------------------------------------------------\n    cfg_local = OmegaConf.to_container(cfg, resolve=True)\n    cfg_local = DictConfig(deepcopy(cfg_local))  # make it editable recursively\n\n    cfg_local.model.hidden_units = int(sample[\"hidden_units\"])\n    cfg_local.training.learning_rate = float(sample[\"learning_rate\"])\n\n    budget_iter = int(sample[\"training_iteration_budget\"])\n    epochs = 1 if trial_mode else int(budget_iter * cfg.training.epochs_per_iteration)\n\n    # Data ----------------------------------------------------------------\n    train_loader, val_loader, _ = get_dataloaders(cfg.dataset, cfg.training)\n\n    # Model / optim -------------------------------------------------------\n    model = build_model(cfg_local.model).to(device)\n    criterion = torch.nn.CrossEntropyLoss()\n    optimizer = torch.optim.Adam(model.parameters(), lr=cfg_local.training.learning_rate)\n\n    best_val_acc = 0.0\n    best_state: Dict = {}\n    global_step = step_offset\n\n    # --------------------------------------------------------------------\n    # Training loop\n    # --------------------------------------------------------------------\n    for epoch in range(1, epochs + 1):\n        model.train()\n        running_loss, correct, total = 0.0, 0, 0\n        for batch_idx, (images, labels) in enumerate(train_loader, 1):\n            images, labels = images.to(device), labels.to(device)\n            optimizer.zero_grad()\n            outputs = model(images)\n            loss = criterion(outputs, labels)\n            loss.backward()\n            optimizer.step()\n\n            running_loss += loss.item() * labels.size(0)\n            preds = outputs.argmax(dim=1)\n            correct += (preds == labels).sum().item()\n            total += labels.size(0)\n\n            # per-batch logging (verbose) --------------------------------\n            wb_run.log({\n                \"phase\": \"train\",\n                \"batch_loss\": loss.item(),\n                \"batch_idx\": batch_idx,\n                \"epoch\": epoch,\n            }, step=global_step)\n            global_step += 1\n\n            # trial-mode —> only 2 batches --------------------------------\n            if trial_mode and batch_idx >= 2:\n                break\n\n        train_loss = running_loss / max(total, 1)\n        train_acc = correct / max(total, 1)\n\n        # --------------------- validation ------------------------------\n        model.eval()\n        val_loss, val_correct, val_total = 0.0, 0, 0\n        with torch.no_grad():\n            for images, labels in val_loader:\n                images, labels = images.to(device), labels.to(device)\n                outputs = model(images)\n                loss = criterion(outputs, labels)\n                val_loss += loss.item() * labels.size(0)\n                val_correct += (outputs.argmax(1) == labels).sum().item()\n                val_total += labels.size(0)\n        val_loss /= max(val_total, 1)\n        val_acc = val_correct / max(val_total, 1)\n\n        if val_acc > best_val_acc:\n            best_val_acc = val_acc\n            best_state = deepcopy(model.state_dict())\n\n        # ------------------------ WandB ---------------------------------\n        wb_run.log({\n            \"epoch\": epoch,\n            \"train_loss\": train_loss,\n            \"train_acc\": train_acc,\n            \"val_loss\": val_loss,\n            \"val_acc\": val_acc,\n            \"hyper/learning_rate\": cfg_local.training.learning_rate,\n            \"hyper/hidden_units\": cfg_local.model.hidden_units,\n            \"hyper/budget_epochs\": epochs,\n        }, step=global_step)\n\n        # trial-mode – single epoch only -------------------------------\n        if trial_mode:\n            break\n\n    wall_time = time.perf_counter() - start\n    return best_val_acc, wall_time, best_state\n\n###############################################################################\n#                                 Main                                        #\n###############################################################################\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=None)\ndef main(cfg: DictConfig) -> None:  # noqa: C901 – complexity unavoidable\n    # ------------------------------------------------------------------\n    # Trial-mode adjustments (should be *lightweight*)\n    # ------------------------------------------------------------------\n    if cfg.trial_mode:\n        cfg.wandb.mode = \"disabled\"\n        cfg.experiment.total_evaluations = 1\n        cfg.experiment.n_init_points = 1\n        cfg.training.epochs_per_iteration = 1\n        cfg.optuna.n_trials = 0\n\n    # ------------------------------------------------------------------\n    # Directories & WandB initialisation\n    # ------------------------------------------------------------------\n    out_dir = Path(hydra.utils.to_absolute_path(cfg.results_dir)) / cfg.run.run_id\n    out_dir.mkdir(parents=True, exist_ok=True)\n\n    # Save **resolved** Hydra config for provenance\n    OmegaConf.save(cfg, out_dir / \"config.yaml\")\n\n    wb_run = wandb.init(\n        mode=cfg.wandb.mode,\n        entity=cfg.wandb.entity,\n        project=cfg.wandb.project,\n        id=cfg.run.run_id,\n        dir=str(out_dir),\n        resume=\"allow\",\n        config=OmegaConf.to_container(cfg, resolve=True),\n    )\n    if wb_run.mode != \"disabled\":\n        print(f\"[WandB] URL: {wb_run.url}\")\n\n    device = torch.device(cfg.training.device if torch.cuda.is_available() else \"cpu\")\n\n    # ------------------------------------------------------------------\n    # BOIL / S-BOIL loop\n    # ------------------------------------------------------------------\n    space = cfg.optuna.search_space\n    rng = np.random.default_rng(seed=42)\n\n    X_enc: List[List[float]] = []   # encoded configuration vectors\n    Y: List[float] = []             # best validation acc per eval\n    costs: List[float] = []         # wall-clock seconds per eval\n    samples: List[Dict] = []        # actual sampled hyper-param dicts\n\n    best_global = -1.0\n    best_state: Dict = {}\n\n    for eval_id in range(cfg.experiment.total_evaluations):\n        # --------------------------------------------------------------\n        # Suggest next configuration\n        # --------------------------------------------------------------\n        if eval_id < cfg.experiment.n_init_points:\n            sample = _sample_from_space(space, rng)\n        else:\n            # Fit accuracy surrogate ------------------------------------------------\n            X_t = torch.tensor(X_enc, dtype=torch.double)\n            Y_t = torch.tensor(Y, dtype=torch.double).unsqueeze(-1)\n            gp = SingleTaskGP(X_t, Y_t)\n            mll = ExactMarginalLogLikelihood(gp.likelihood, gp)\n            fit_gpytorch_model(mll)\n            best_y = max(Y)\n\n            # Cost surrogate (log-seconds) ----------------------------------------\n            lr_cost = LinearRegression().fit(np.array(X_enc), np.log(np.array(costs) + 1e-8))\n\n            # Evaluate acquisition on a random candidate set ----------------------\n            candidate_pool = [_sample_from_space(space, rng) for _ in range(512)]\n            X_pool = torch.tensor([_encode_x(s, space) for s in candidate_pool], dtype=torch.double)\n            posterior = gp.posterior(X_pool)\n            mu, var = posterior.mean.squeeze(-1), posterior.variance.squeeze(-1)\n            sigma = var.clamp_min(1e-12).sqrt()\n            # Expected Improvement (analytical)\n            z = (mu - best_y) / sigma\n            norm = torch.distributions.Normal(torch.zeros_like(z), torch.ones_like(z))\n            ei = (mu - best_y) * norm.cdf(z) + sigma * norm.log_prob(z).exp()\n            ei = ei.clamp_min(1e-12)\n\n            # Predicted cost -------------------------------------------------------\n            cost_pred = np.exp(lr_cost.predict(X_pool.cpu().numpy()))\n            cost_pred = torch.from_numpy(cost_pred).double().clamp_min(1e-6)\n\n            if cfg.experiment.acquisition.lower() == \"boil\":\n                acquisition = torch.log(ei) - torch.log(cost_pred)\n            elif cfg.experiment.acquisition.lower() == \"s-boil\":\n                betas = torch.tensor([\n                    s.get(\"beta\", cfg.experiment.beta_default) for s in candidate_pool\n                ], dtype=torch.double, device=ei.device)\n                acquisition = torch.log(ei) - betas * var - torch.log(cost_pred)\n            else:\n                raise ValueError(f\"Unknown acquisition kind {cfg.experiment.acquisition}\")\n\n            sample = candidate_pool[int(torch.argmax(acquisition).item())]\n\n        # --------------------------------------------------------------\n        # Evaluate the chosen configuration\n        # --------------------------------------------------------------\n        wb_run.log({f\"suggested/{k}\": v for k, v in sample.items()}, step=eval_id)\n        val_acc, wall_time, best_state_local = _train_once(\n            sample, cfg, device, cfg.trial_mode, wb_run, step_offset=eval_id * 10_000  # separate step ranges\n        )\n\n        X_enc.append(_encode_x(sample, space))\n        Y.append(val_acc)\n        costs.append(wall_time)\n        samples.append(sample)\n\n        wb_run.log({\n            \"evaluation_id\": eval_id,\n            \"val_acc\": val_acc,\n            \"wall_time\": wall_time,\n            \"best_val_acc_so_far\": max(Y),\n        }, step=(eval_id + 1) * 10_000)\n\n        if val_acc > best_global:\n            best_global = val_acc\n            best_state = deepcopy(best_state_local)\n            wb_run.summary[\"best_val_accuracy\"] = best_global\n\n        # First time >=80 %? -------------------------------------------------------\n        if val_acc >= 0.8 and \"time_to_target\" not in wb_run.summary:\n            wb_run.summary[\"time_to_target\"] = float(sum(costs))\n            wb_run.summary[\"evals_to_target\"] = eval_id + 1\n\n        # Trial-mode → single evaluation only -------------------------------------\n        if cfg.trial_mode:\n            break\n\n    wb_run.summary[\"total_wall_time\"] = float(sum(costs))\n\n    # ----------------------------------------------------------------------\n    # Persist *globally* best network weights for later confusion matrix\n    # ----------------------------------------------------------------------\n    if best_state:\n        torch.save(best_state, out_dir / \"best_model.pt\")\n        wb_run.save(str(out_dir / \"best_model.pt\"), base_path=str(out_dir))\n\n    wandb.finish()\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "evaluate_py": "\"\"\"src/evaluate.py\nIndependent evaluation / visualisation script that is **not** called by\n``src.main``.  It fetches time-series metrics from WandB for a list of\nrun-IDs, generates per-run artefacts (JSON + plots) and finally produces\nan aggregated comparison across all runs (bar-chart + significance test\n+ JSON).\n\"\"\"\nfrom __future__ import annotations\n\nimport argparse\nimport json\nimport math\nimport os\nfrom pathlib import Path\nfrom typing import Dict, List\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nimport wandb\nfrom omegaconf import OmegaConf\nfrom scipy import stats\nfrom sklearn.metrics import ConfusionMatrixDisplay, confusion_matrix\n\nfrom .model import build_model\nfrom .preprocess import get_dataloaders\n\n# ---------------------------------------------------------------------------\n#                            Utility helpers                                 \n# ---------------------------------------------------------------------------\n\ndef _save_json(path: Path, obj) -> None:\n    path.parent.mkdir(parents=True, exist_ok=True)\n    with path.open(\"w\", encoding=\"utf-8\") as fh:\n        json.dump(obj, fh, indent=2, sort_keys=False)\n\n\ndef _plot_learning_curve(df, run_dir: Path, run_id: str) -> Path:\n    \"\"\"Line-plot of validation / training accuracy over *epoch* granularity.\"\"\"\n    fig, ax = plt.subplots(figsize=(6, 4))\n    if \"val_acc\" in df.columns:\n        ax.plot(df[\"val_acc\"], label=\"Validation\", linewidth=2)\n    if \"train_acc\" in df.columns:\n        ax.plot(df[\"train_acc\"], label=\"Training\", alpha=0.5)\n    ax.set_xlabel(\"Logged step\")\n    ax.set_ylabel(\"Accuracy\")\n    ax.set_title(f\"Learning curve – {run_id}\")\n    ax.legend()\n    fig.tight_layout()\n    path = run_dir / f\"{run_id}_learning_curve.pdf\"\n    fig.savefig(path)\n    plt.close(fig)\n    return path\n\n\ndef _plot_confusion(run_cfg: Dict, model_path: Path, run_dir: Path, run_id: str):\n    if not model_path.exists():\n        return None  # confusion matrix impossible without a model\n\n    import torch\n\n    cfg = Dict(run_cfg) if isinstance(run_cfg, dict) else run_cfg\n    # Build *test* loader only\n    _, _, test_loader = get_dataloaders(cfg[\"dataset\"], cfg[\"training\"])\n    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n    model = build_model(cfg[\"model\"]).to(device)\n    model.load_state_dict(torch.load(model_path, map_location=device))\n    model.eval()\n\n    all_preds, all_labels = [], []\n    with torch.no_grad():\n        for images, labels in test_loader:\n            images = images.to(device)\n            preds = model(images).argmax(1).cpu().numpy()\n            all_preds.append(preds)\n            all_labels.append(labels.numpy())\n    y_pred = np.concatenate(all_preds)\n    y_true = np.concatenate(all_labels)\n\n    cm = confusion_matrix(y_true, y_pred)\n    disp = ConfusionMatrixDisplay(cm)\n    disp.plot(cmap=\"Blues\")\n    plt.title(f\"Confusion Matrix – {run_id}\")\n    plt.tight_layout()\n    path = run_dir / f\"{run_id}_confusion_matrix.pdf\"\n    plt.savefig(path)\n    plt.close()\n    return path\n\n# ---------------------------------------------------------------------------\n#                             Main routine                                    \n# ---------------------------------------------------------------------------\n\ndef main() -> None:\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"results_dir\", type=str, help=\"Directory that contains training artefacts\")\n    parser.add_argument(\"run_ids\", type=str, help='JSON list of run-IDs, e.g. \"[\\\"run-1\\\", \\\"run-2\\\"]\"')\n    args = parser.parse_args()\n\n    out_root = Path(args.results_dir).expanduser().resolve()\n    run_ids: List[str] = json.loads(args.run_ids)\n\n    # ----------------------------------------------------------------------\n    # Retrieve global WandB information from first run's config\n    # ----------------------------------------------------------------------\n    first_cfg_path = out_root / run_ids[0] / \"config.yaml\"\n    cfg_global = OmegaConf.to_container(OmegaConf.load(first_cfg_path), resolve=True)\n    entity, project = cfg_global[\"wandb\"][\"entity\"], cfg_global[\"wandb\"][\"project\"]\n\n    api = wandb.Api()\n\n    aggregated: Dict[str, Dict] = {}\n    per_run_generated_paths: List[str] = []\n\n    for rid in run_ids:\n        run_dir = out_root / rid\n        run_dir.mkdir(parents=True, exist_ok=True)\n\n        # ------------------- pull from WandB --------------------------------\n        wb_run = api.run(f\"{entity}/{project}/{rid}\")\n        history_df = wb_run.history(pandas=True)  # DataFrame\n        summary = wb_run.summary._json_dict\n        config = dict(wb_run.config)\n\n        # ------------------- dump raw metrics ------------------------------\n        metrics_path = run_dir / \"metrics.json\"\n        _save_json(metrics_path, {\n            \"history\": history_df.to_dict(orient=\"list\"),\n            \"summary\": summary,\n            \"config\": config,\n        })\n        per_run_generated_paths.append(str(metrics_path))\n\n        # ------------------- figures: learning curve -----------------------\n        lc_path = _plot_learning_curve(history_df, run_dir, rid)\n        per_run_generated_paths.append(str(lc_path))\n\n        # ------------------- figures: confusion matrix ---------------------\n        cm_path = _plot_confusion(config, run_dir / \"best_model.pt\", run_dir, rid)\n        if cm_path is not None:\n            per_run_generated_paths.append(str(cm_path))\n\n        # ------------------- store aggregate stats -------------------------\n        aggregated[rid] = {\n            \"method\": config.get(\"run\", {}).get(\"method\", \"unknown\"),\n            \"best_val_acc\": summary.get(\"best_val_accuracy\"),\n            \"time_to_target\": summary.get(\"time_to_target\"),\n            \"evals_to_target\": summary.get(\"evals_to_target\"),\n            \"total_wall_time\": summary.get(\"total_wall_time\"),\n        }\n\n    # ----------------------------------------------------------------------\n    # Aggregated comparison across runs                                     \n    # ----------------------------------------------------------------------\n    comp_dir = out_root / \"comparison\"\n    comp_dir.mkdir(parents=True, exist_ok=True)\n\n    # Save raw aggregated dict --------------------------------------------\n    _save_json(comp_dir / \"aggregated_metrics.json\", aggregated)\n\n    # Separate into methods ------------------------------------------------\n    method_to_accs: Dict[str, List[float]] = {}\n    for stats in aggregated.values():\n        method = stats[\"method\"]\n        method_to_accs.setdefault(method, []).append(stats[\"best_val_acc\"])\n\n    # Improvement-rate vs baseline (first alphabetical method assumed baseline if BOIL present)\n    baseline_name = \"BOIL\" if \"BOIL\" in method_to_accs else sorted(method_to_accs)[0]\n    baseline_mean = float(np.mean(method_to_accs[baseline_name]))\n    improvements: Dict[str, float] = {\n        m: (float(np.mean(accs)) - baseline_mean) / baseline_mean\n        for m, accs in method_to_accs.items() if m != baseline_name\n    }\n\n    # t-tests --------------------------------------------------------------\n    significance: Dict[str, float] = {}\n    for m, accs in method_to_accs.items():\n        if m == baseline_name:\n            continue\n        t_val, p_val = stats.ttest_ind(accs, method_to_accs[baseline_name], equal_var=False)\n        significance[m] = p_val\n\n    # Store derived metrics -----------------------------------------------\n    derived_path = comp_dir / \"aggregated_derived_metrics.json\"\n    _save_json(derived_path, {\n        \"baseline\": baseline_name,\n        \"baseline_mean\": baseline_mean,\n        \"improvement_rate\": improvements,\n        \"p_values_vs_baseline\": significance,\n    })\n    per_run_generated_paths.append(str(derived_path))\n\n    # --------------------------- bar-chart -------------------------------\n    plt.figure(figsize=(6, 4))\n    sns.barplot(x=list(method_to_accs.keys()), y=[np.mean(v) for v in method_to_accs.values()])\n    plt.ylabel(\"Mean best validation accuracy\")\n    plt.title(\"Best accuracy per method\")\n    for idx, acc_mean in enumerate([np.mean(v) for v in method_to_accs.values()]):\n        plt.text(idx, acc_mean + 0.002, f\"{acc_mean:.3f}\", ha=\"center\")\n    plt.tight_layout()\n    bar_path = comp_dir / \"comparison_accuracy_bar_chart.pdf\"\n    plt.savefig(bar_path)\n    plt.close()\n    per_run_generated_paths.append(str(bar_path))\n\n    # --------------------------- box-plot --------------------------------\n    data, labels = [], []\n    for m, accs in method_to_accs.items():\n        data.extend(accs)\n        labels.extend([m] * len(accs))\n    plt.figure(figsize=(6, 4))\n    sns.boxplot(x=labels, y=data)\n    plt.ylabel(\"Best validation accuracy\")\n    plt.title(\"Distribution of best accuracy across seeds\")\n    plt.tight_layout()\n    box_path = comp_dir / \"comparison_accuracy_box_plot.pdf\"\n    plt.savefig(box_path)\n    plt.close()\n    per_run_generated_paths.append(str(box_path))\n\n    # --------------------------- print paths -----------------------------\n    for p in per_run_generated_paths:\n        print(p)\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "preprocess_py": "\"\"\"src/preprocess.py\nDataset loading & preprocessing utilities.  Currently supports the\nFashion-MNIST dataset.\n\"\"\"\nfrom __future__ import annotations\n\nfrom typing import Tuple\n\nimport torch\nimport torchvision.transforms as T\nfrom omegaconf import DictConfig\nfrom torch.utils.data import DataLoader, random_split\nfrom torchvision.datasets import FashionMNIST\n\n\n###############################################################################\n#                            Transform parsing                                #\n###############################################################################\n\ndef _parse_transforms(entries):\n    \"\"\"Turn YAML-provided *entries* into a torchvision.Compose object.\"\"\"\n    transforms = []\n    for e in entries:\n        # Simple string e.g. \"ToTensor\" or \"Normalize\"\n        if isinstance(e, str):\n            e_lc = e.lower()\n            if e_lc == \"totensor\":\n                transforms.append(T.ToTensor())\n            elif e_lc.startswith(\"normalize\"):\n                # Allow shorthand \"Normalize(mean=0.5,std=0.5)\"\n                mean, std = 0.5, 0.5\n                if \"(\" in e and \")\" in e:\n                    # crude parsing (\"Normalize(mean=0.3,std=0.7)\")\n                    inside = e[e.find(\"(\") + 1 : e.find(\")\")]\n                    parts = {k.strip(): float(v) for k, v in (p.split(\"=\") for p in inside.split(\",\"))}\n                    mean = parts.get(\"mean\", 0.5)\n                    std = parts.get(\"std\", 0.5)\n                transforms.append(T.Normalize(mean=[mean], std=[std]))\n            else:\n                raise ValueError(f\"Unknown transform entry {e!r}\")\n        elif isinstance(e, dict):\n            # Full YAML form e.g. {Normalize: {mean: 0.5, std: 0.5}}\n            if \"Normalize\" in e:\n                pars = e[\"Normalize\"]\n                transforms.append(T.Normalize(mean=[pars.get(\"mean\", 0.5)], std=[pars.get(\"std\", 0.5)]))\n            else:\n                raise ValueError(f\"Unknown dict-transform {e}\")\n        else:\n            raise TypeError(f\"Transform entries must be str or dict, got {type(e)}\")\n    return T.Compose(transforms)\n\n\n###############################################################################\n#                        Public  get_dataloaders                              #\n###############################################################################\n\ndef get_dataloaders(ds_cfg: DictConfig, train_cfg: DictConfig) -> Tuple[DataLoader, DataLoader, DataLoader]:\n    \"\"\"Return *train*, *validation*, *test* DataLoaders for Fashion-MNIST.\"\"\"\n    if ds_cfg.name.lower() != \"fashion-mnist\":\n        raise NotImplementedError(\"Only Fashion-MNIST is supported right now.\")\n\n    transform = _parse_transforms(ds_cfg.transforms)\n\n    root = \".cache/torchvision/fashion_mnist\"\n    train_full = FashionMNIST(root=root, train=True, download=True, transform=transform)\n    test_set = FashionMNIST(root=root, train=False, download=True, transform=transform)\n\n    val_ratio = ds_cfg.validation_split\n    val_size = int(len(train_full) * val_ratio)\n    train_size = len(train_full) - val_size\n    train_subset, val_subset = random_split(train_full, [train_size, val_size])\n\n    common = dict(batch_size=train_cfg.batch_size, num_workers=train_cfg.num_workers, pin_memory=train_cfg.pin_memory)\n\n    train_loader = DataLoader(train_subset, shuffle=True, **common)\n    val_loader = DataLoader(val_subset, shuffle=False, **common)\n    test_loader = DataLoader(test_set, shuffle=False, **common)\n    return train_loader, val_loader, test_loader\n",
    "model_py": "\"\"\"src/model.py\nAll neural-network architectures used in this project.  At the moment we\nonly need a two-layer MLP for Fashion-MNIST, but the *factory* at the end\nmakes it trivial to add more models.\n\"\"\"\nfrom __future__ import annotations\n\nfrom typing import Any\n\nimport torch.nn as nn\nfrom omegaconf import DictConfig\n\n\nclass TwoLayerMLP(nn.Module):\n    \"\"\"A very small two-layer MLP (~1.2 M parameters for 256 hidden units).\"\"\"\n\n    def __init__(\n        self,\n        input_dim: int,\n        hidden_units: int,\n        output_classes: int,\n        activation: str = \"relu\",\n        weight_init: str = \"kaiming_uniform\",\n    ) -> None:\n        super().__init__()\n        act_cls: Any = getattr(nn, activation.capitalize(), nn.ReLU)\n        self.net = nn.Sequential(\n            nn.Flatten(),\n            nn.Linear(input_dim, hidden_units),\n            act_cls(),\n            nn.Linear(hidden_units, output_classes),\n        )\n        self.apply(lambda m: self._init_weights(m, weight_init))\n\n    @staticmethod\n    def _init_weights(module: nn.Module, scheme: str):\n        if not isinstance(module, nn.Linear):\n            return\n        if scheme == \"kaiming_uniform\":\n            nn.init.kaiming_uniform_(module.weight, nonlinearity=\"relu\")\n        elif scheme == \"kaiming_normal\":\n            nn.init.kaiming_normal_(module.weight, nonlinearity=\"relu\")\n        elif scheme == \"xavier_uniform\":\n            nn.init.xavier_uniform_(module.weight)\n        elif scheme == \"xavier_normal\":\n            nn.init.xavier_normal_(module.weight)\n        else:\n            raise ValueError(f\"Unknown weight-init scheme {scheme}\")\n        if module.bias is not None:\n            nn.init.constant_(module.bias, 0.0)\n\n    def forward(self, x):  # noqa: D401 ‑ one-liner docstring not required\n        return self.net(x)\n\n\n# ---------------------------------------------------------------------------\n#                               Factory                                       \n# ---------------------------------------------------------------------------\n\ndef build_model(cfg: DictConfig):\n    name = cfg.name.lower()\n    if name == \"two-layer-mlp-1.2m\":\n        return TwoLayerMLP(\n            input_dim=cfg.input_dim,\n            hidden_units=cfg.hidden_units,\n            output_classes=cfg.output_classes,\n            activation=cfg.activation,\n            weight_init=cfg.weight_init,\n        )\n    raise NotImplementedError(f\"Unknown model name {cfg.name}\")\n",
    "main_py": "\"\"\"src/main.py\nOrchestrator.  This module parses the top-level Hydra config, performs\ntrial-mode adjustments and then spawns the *real* training process\n(`src.train`) as a subprocess so that Hydra can create a *second* config\ncontext for the child process.  The indirection keeps the two Hydra\ncontexts cleanly separated (top-level orchestration vs. actual\nexperiment).\n\"\"\"\nfrom __future__ import annotations\n\nimport subprocess\nimport sys\nfrom typing import List\n\nimport hydra\nfrom omegaconf import DictConfig\n\n\n@hydra.main(config_path=\"../config\", config_name=\"config\", version_base=None)\ndef main(cfg: DictConfig) -> None:\n    \"\"\"Entry-point for the experiment orchestrator.\"\"\"\n\n    # Build Hydra override strings that we forward to the *child* process\n    overrides: List[str] = [\n        f\"run={cfg.run.run_id}\",\n        f\"results_dir={cfg.results_dir}\",\n        f\"wandb.mode={cfg.wandb.mode}\",\n    ]\n    if cfg.trial_mode:\n        overrides.append(\"trial_mode=true\")\n\n    cmd = [sys.executable, \"-u\", \"-m\", \"src.train\", *overrides]\n    print(\"[main.py] Launching child process:\\n \", \" \".join(cmd))\n    subprocess.run(cmd, check=True)\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "pyproject_toml": "[build-system]\nrequires = [\"setuptools>=61.0\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"s-boil-experiment\"\nversion = \"0.1.0\"\nrequires-python = \">=3.9\"\ndependencies = [\n  \"torch>=2.0\",\n  \"torchvision>=0.15\",\n  \"hydra-core>=1.3\",\n  \"wandb>=0.15\",\n  \"botorch>=0.8.5\",\n  \"gpytorch>=1.11\",\n  \"optuna>=3.4\",\n  \"scikit-learn>=1.3\",\n  \"pandas>=2.0\",\n  \"matplotlib>=3.7\",\n  \"seaborn>=0.12\",\n  \"numpy>=1.24\",\n  \"scipy>=1.10\"\n]\n\n[tool.setuptools.packages.find]\nwhere = [\"src\"]\n",
    "config_yaml": "# config/config.yaml – global Hydra configuration\n\n# Order matters: later entries override earlier ones.  ``run={id}`` on the\n# command-line will merge ``config/run/{id}.yaml`` *after* this file.\n\ndefaults:\n  - _self_\n\n# ---------------------------------------------------------------------------\nrun:\n  run_id: default-run\n  method: baseline\n\n# ---------------------------------------------------------------------------\nwandb:\n  entity: gengaru617-personal\n  project: 251023-test\n  mode: online  # automatically set to \"disabled\" in trial_mode\n\n# ---------------------------------------------------------------------------\n# MODEL & DATA – sensible defaults (overridden by run-specific YAML files)\nmodel:\n  name: two-layer-mlp-1.2m\n  input_dim: 784\n  hidden_units: 256\n  output_classes: 10\n  activation: relu\n  weight_init: kaiming_uniform\n\ndataset:\n  name: fashion-mnist\n  transforms:\n    - ToTensor\n    - Normalize(mean=0.5, std=0.5)\n  validation_split: 0.1\n\ntraining:\n  batch_size: 128\n  optimizer: adam\n  device: cuda\n  learning_rate: 1e-3\n  epochs_per_iteration: 5\n  num_workers: 4\n  pin_memory: true\n\n# ---------------------------------------------------------------------------\nexperiment:\n  n_init_points: 3\n  total_evaluations: 30\n  acquisition: boil  # or s-boil\n  beta_default: 1.0\n\noptuna:  # only used for search-space definition (we don't run Optuna itself)\n  n_trials: 30\n  search_space:\n    learning_rate: {type: loguniform, low: 1e-4, high: 1e-1}\n    hidden_units:   {type: int,        low: 64,  high: 512}\n    training_iteration_budget: {type: int, low: 1, high: 15}\n    # beta only used for S-BOIL; harmless otherwise\n    beta: {type: categorical, choices: [0.5, 1.0]}\n\n# ---------------------------------------------------------------------------\nresults_dir: outputs\ntrial_mode: false\n"
}
